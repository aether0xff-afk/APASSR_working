"""Reporting utilities for HTB-style experiments."""
from __future__ import annotations

import json
from pathlib import Path
from typing import Dict, List

from pentesting_rl.metrics import compute_metrics
from pentesting_rl.state_model import estimate_info_gain, state_signature


def generate_reports(
    report_dir: str | Path,
    history: List[Dict[str, object]],
    knowledge_store: Dict[str, List[str]],
    window: int = 5,
) -> Dict[str, Path]:
    report_path = Path(report_dir)
    report_path.mkdir(parents=True, exist_ok=True)

    run_log = build_run_log(history)
    graph = build_transition_graph(history, window=window)
    knowledge_snapshot = build_knowledge_snapshot(knowledge_store, graph)
    metrics = compute_metrics(history, knowledge_store, window=window)
    report_text = build_report(metrics, knowledge_snapshot, graph)

    run_file = report_path / "run.json"
    knowledge_file = report_path / "knowledge.json"
    graph_file = report_path / "graph.json"
    report_file = report_path / "report.md"

    _write_json(run_file, run_log)
    _write_json(knowledge_file, knowledge_snapshot)
    _write_json(graph_file, graph)
    report_file.write_text(report_text, encoding="utf-8")

    return {
        "run": run_file,
        "knowledge": knowledge_file,
        "graph": graph_file,
        "report": report_file,
    }


def build_run_log(history: List[Dict[str, object]]) -> Dict[str, object]:
    entries: List[Dict[str, object]] = []
    for idx, transition in enumerate(history):
        meta = transition.get("meta", {}) or {}
        action = transition.get("a_t", {}) or {}
        state = transition.get("s_t", {}) or {}
        entry = {
            "step": meta.get("step", idx),
            "episode": meta.get("episode"),
            "tool": action.get("tool"),
            "options": action.get("options"),
            "command": transition.get("command"),
            "reward": action.get("reward"),
            "external_reward": action.get("external_reward"),
            "intrinsic_reward": action.get("intrinsic_reward"),
            "cost_penalty": action.get("cost_penalty"),
            "cost": state.get("cost", {}),
            "safety": state.get("safety", {}),
            "new_kk": sorted(list(state.get("updated_kk", []) or [])),
            "updates_detail": transition.get("updates_detail", {}),
        }
        entries.append(entry)
    return {"steps": entries}


def build_knowledge_snapshot(
    knowledge_store: Dict[str, List[str]],
    graph: Dict[str, object],
) -> Dict[str, object]:
    artifacts = {
        "endpoints": _collect_unique(
            knowledge_store,
            [
                "PATH_HINT",
                "LINK_FOUND",
                "FORM_ACTION",
                "SCRIPT_SRC",
                "JS_ENDPOINT",
                "ROBOTS_DISALLOW",
                "ROBOTS_ALLOW",
                "SITEMAP_URL",
            ],
        ),
        "params": _collect_unique(knowledge_store, ["PARAM_DETECTED"]),
        "cookies": _collect_unique(knowledge_store, ["COOKIE_SEEN", "HTTP_SET_COOKIE"]),
    }
    return {
        "kk_store": {key: list(values) for key, values in knowledge_store.items()},
        "artifacts": artifacts,
        "state_graph": {
            "node_count": len(graph.get("nodes", [])),
            "edge_count": len(graph.get("edges", [])),
        },
    }


def build_transition_graph(
    history: List[Dict[str, object]],
    window: int = 5,
) -> Dict[str, object]:
    nodes: Dict[str, Dict[str, object]] = {"START": {"summary": {"type": "start"}}}
    edges: List[Dict[str, object]] = []

    seen_paths: set[str] = set()
    seen_params: set[str] = set()
    seen_cookies: set[str] = set()

    prev_id = "START"
    for idx, transition in enumerate(history):
        state_id, summary = state_signature(history, idx, window=window)
        if state_id not in nodes:
            nodes[state_id] = {"summary": summary}

        gain, new_paths, new_params, new_cookies = estimate_info_gain(
            transition, seen_paths, seen_params, seen_cookies
        )
        action = transition.get("a_t", {}) or {}
        state = transition.get("s_t", {}) or {}
        meta = transition.get("meta", {}) or {}
        edges.append(
            {
                "from": prev_id,
                "to": state_id,
                "step": meta.get("step", idx),
                "tool": action.get("tool"),
                "options": action.get("options"),
                "reward": action.get("reward"),
                "cost": state.get("cost", {}),
                "info_gain": gain,
                "new_paths": new_paths,
                "new_params": new_params,
                "new_cookies": new_cookies,
            }
        )
        prev_id = state_id

    return {
        "nodes": [{"id": node_id, **payload} for node_id, payload in nodes.items()],
        "edges": edges,
        "window": window,
    }


def build_report(
    metrics: Dict[str, object],
    knowledge_snapshot: Dict[str, object],
    graph: Dict[str, object],
) -> str:
    artifacts = knowledge_snapshot.get("artifacts", {})
    endpoints = artifacts.get("endpoints", [])
    params = artifacts.get("params", [])
    cookies = artifacts.get("cookies", [])

    lines = [
        "# HTB Web RL Report",
        "",
        "## Overview",
        f"- Total endpoints: {len(endpoints)}",
        f"- Total params: {len(params)}",
        f"- Total cookies: {len(cookies)}",
        f"- State nodes: {len(graph.get('nodes', []))}",
        f"- State edges: {len(graph.get('edges', []))}",
        "",
        "## Metrics",
        f"- IG/request: {metrics.get('ig_per_request')}",
        f"- Steps to first transition: {metrics.get('steps_to_first_transition')}",
        f"- Steps to deep state: {metrics.get('steps_to_deep_state')}",
        "",
        "## Observed Surfaces (sample)",
        f"- Endpoints: {', '.join(endpoints[:10])}",
        f"- Params: {', '.join(params[:10])}",
        f"- Cookies: {', '.join(cookies[:10])}",
        "",
        "## State Transitions",
        "- This report focuses on observed transitions without vulnerability labels.",
        "",
        "## Cost Summary",
        f"- Total requests: {metrics.get('total_requests')}",
        "",
        "## Policy Trace (sample)",
        "- See run.json for full step-by-step actions.",
        "",
    ]
    return "\n".join(lines)


def _collect_unique(store: Dict[str, List[str]], keys: List[str]) -> List[str]:
    values: set[str] = set()
    for key in keys:
        for value in store.get(key, []) or []:
            values.add(str(value))
    return sorted(values)


def _write_json(path: Path, payload: Dict[str, object]) -> None:
    path.write_text(json.dumps(payload, indent=2, ensure_ascii=True), encoding="utf-8")
