"""Tokenization helpers for novelty scoring and path summarization."""
from __future__ import annotations

import re
from dataclasses import dataclass
from typing import Iterable, Mapping, Sequence


_SQL_ERROR_PATTERN = re.compile(r"sql syntax|sql error|mysql|postgres|sqlite", re.IGNORECASE)
_STACKTRACE_PATTERN = re.compile(r"traceback|stack trace|exception", re.IGNORECASE)

_VERSION_PRODUCTS = {
    "nginx": "nginx",
    "apache": "apache",
    "httpd": "apache",
    "php": "php",
    "wordpress": "wordpress",
    "wp": "wordpress",
    "tomcat": "tomcat",
    "iis": "iis",
}


@dataclass(frozen=True)
class ActionDescriptor:
    tool: str
    what: str
    how: str
    where: str
    command: str | None = None


def extract_top_level_path(url_or_path: str) -> str:
    """Return the top-level path segment or '/' for invalid input."""
    if not isinstance(url_or_path, str):
        return "/"
    path = url_or_path.strip()
    if not path:
        return "/"
    if "://" in path:
        path = path.split("://", 1)[1]
        path = path.split("/", 1)[1] if "/" in path else ""
    if "?" in path:
        path = path.split("?", 1)[0]
    if "#" in path:
        path = path.split("#", 1)[0]
    if path.startswith("/"):
        path = path[1:]
    if not path:
        return "/"
    segment = path.split("/", 1)[0]
    return f"/{segment}"


def tokenize_action(action: ActionDescriptor) -> set[str]:
    tokens = set()
    if action.tool:
        tokens.add(f"tool:{action.tool}")
    if action.what:
        tokens.add(f"what:{action.what}")
    if action.how:
        tokens.add(f"how:{action.how}")
    if action.where:
        tokens.add(f"where:{action.where}")
    proto = _infer_proto(action.command or "")
    tokens.add(f"proto:{proto}")
    return tokens


def tokenize_discovery(
    new_values: Mapping[str, Sequence[str]] | None,
    output: str | None = None,
) -> set[str]:
    tokens: set[str] = set()
    if not new_values:
        return tokens

    for entry in new_values.get("Open_Ports", []):
        port = _extract_port(entry)
        if port:
            tokens.add(f"new_port:{port}")
    for entry in new_values.get("Services", []):
        service = _extract_service(entry)
        if service:
            tokens.add(f"new_service:{service}")

    path_sources = (
        "PATH_HINT",
        "LINK_FOUND",
        "FORM_ACTION",
        "SCRIPT_SRC",
        "JS_ENDPOINT",
        "ROBOTS_DISALLOW",
        "ROBOTS_ALLOW",
        "SITEMAP_URL",
        "HTTP_HEADER_LOCATION",
    )
    for key in path_sources:
        for path in new_values.get(key, []):
            top = extract_top_level_path(str(path))
            tokens.add(f"new_path_top:{top}")

    for status in new_values.get("HTTP_STATUS_CODE", []):
        status_str = str(status)
        if status_str in {"401", "403"}:
            tokens.add(f"auth_gate:{status_str}")
    if new_values.get("HTTP_STATUS_302"):
        tokens.add("auth_gate:redirect_login")

    if _contains_login_path(new_values):
        tokens.add("auth_gate:redirect_login")

    version_sources = list(new_values.get("HTTP_SERVER_HEADER", []))
    version_sources.extend(new_values.get("Service_Versions", []))
    version_sources.extend(new_values.get("Script_Output", []))
    for entry in version_sources:
        product = _extract_product(str(entry))
        if product:
            tokens.add(f"version_leak:{product}")

    combined_text = "\n".join(
        [
            *[str(v) for v in new_values.get("HTTP_BODY_SNIPPET", [])],
            *[str(v) for v in new_values.get("Script_Output", [])],
            output or "",
        ]
    )
    if _SQL_ERROR_PATTERN.search(combined_text):
        tokens.add("error_leak:sql_error")
    if _STACKTRACE_PATTERN.search(combined_text):
        tokens.add("error_leak:stacktrace")

    if new_values.get("ERROR_DISCLOSURE_PATTERN"):
        tokens.add("error_leak:stacktrace")

    return tokens


def summarize_paths_top(paths: Iterable[str]) -> list[str]:
    summary = {extract_top_level_path(path) for path in paths if path}
    return sorted(summary)


def _extract_port(value: str) -> str:
    if not value:
        return ""
    value = str(value)
    if "/" in value:
        _, port = value.split("/", 1)
        return port
    return value


def _extract_service(value: str) -> str:
    if not value:
        return ""
    value = str(value)
    if ":" in value:
        _, service = value.split(":", 1)
        return service.strip()
    return value.strip()


def _infer_proto(command: str) -> str:
    lowered = command.lower()
    if "https://" in lowered:
        return "https"
    if "http://" in lowered:
        return "http"
    return "tcp"


def _extract_product(text: str) -> str:
    lowered = text.lower()
    for key, normalized in _VERSION_PRODUCTS.items():
        if key in lowered:
            return normalized
    return ""


def _contains_login_path(new_values: Mapping[str, Sequence[str]]) -> bool:
    for key in ("PATH_HINT", "HTTP_HEADER_LOCATION", "LINK_FOUND"):
        for value in new_values.get(key, []):
            if "login" in str(value).lower():
                return True
    return False
