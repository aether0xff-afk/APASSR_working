"""Streamlit GUI for running the DMP loop and browsing run artifacts."""
from __future__ import annotations

import pathlib
import sys

if __package__ in {None, ""}:
    sys.path.append(str(pathlib.Path(__file__).resolve().parent.parent))
    __package__ = "pentesting_rl"

import json
import threading
import time
from pathlib import Path
from typing import Any, Dict, List

import streamlit as st

from pentesting_rl.demo import build_demo_policy, nmap_executor, tool_aware_executor
from pentesting_rl.dmp import DMPConfig, DecisionMakingProcess
from pentesting_rl.run_session import RunSession
from pentesting_rl.target_utils import parse_base_url


def _run_loop(
    dmp: DecisionMakingProcess,
    steps: int,
    executor,
    session: RunSession,
    stop_event: threading.Event,
) -> None:
    session.attach(dmp)
    try:
        for _ in range(steps):
            if stop_event.is_set():
                break
            dmp.step(executor=executor)
    finally:
        session.finalize(dmp.knowledge.store)
        session.detach(dmp)


def _load_runlog(run_dir: Path) -> List[Dict[str, Any]]:
    runlog_path = run_dir / "runlog.jsonl"
    if not runlog_path.exists():
        return []
    entries: List[Dict[str, Any]] = []
    for line in runlog_path.read_text(encoding="utf-8").splitlines():
        if not line.strip():
            continue
        entries.append(json.loads(line))
    return entries


def _load_report(run_dir: Path) -> Dict[str, Any] | None:
    report_path = run_dir / "report.json"
    if not report_path.exists():
        return None
    return json.loads(report_path.read_text(encoding="utf-8"))


def _safe_rerun() -> None:
    rerun = getattr(st, "rerun", None)
    if callable(rerun):
        rerun()
        return
    experimental_rerun = getattr(st, "experimental_rerun", None)
    if callable(experimental_rerun):
        experimental_rerun()
        return


def _format_reward(reward: Dict[str, Any]) -> str:
    if not reward:
        return "total=0.00"
    total = reward.get("total", 0.0)
    parts = [
        f"total={total:.2f}",
        f"success={reward.get('success', 0.0):.2f}",
        f"infogain={reward.get('infogain', 0.0):.2f}",
        f"prophecy={reward.get('prophecy', 0.0):.2f}",
        f"novelty={reward.get('novelty', 0.0):.2f}",
        f"cost={reward.get('cost', 0.0):.2f}",
    ]
    return ", ".join(parts)


def _format_imagination(imagination: Dict[str, Any]) -> str:
    if not imagination:
        return "imagination: off"
    mode = imagination.get("mode", "policy")
    rollouts = imagination.get("rollouts", 0)
    best_estimate = imagination.get("best_estimate")
    candidates = imagination.get("candidates", [])
    lines = [f"imagination: mode={mode}, rollouts={rollouts}"]
    if best_estimate is not None:
        lines.append(f"best_estimate={best_estimate:.2f}")
    if candidates:
        top = sorted(
            candidates,
            key=lambda c: c.get("estimated_reward", -9999),
            reverse=True,
        )[:3]
        for idx, cand in enumerate(top, start=1):
            tool = cand.get("tool", "")
            opts = cand.get("options", ("", "", ""))
            est = cand.get("estimated_reward", 0.0)
            lines.append(f"candidate#{idx}: tool={tool} options={opts} est={est:.2f}")
    return "\n".join(lines)


def _format_runlog_entry(entry: Dict[str, Any]) -> str:
    action = entry.get("action", {})
    tool = action.get("tool", "")
    options = action.get("options", ("", "", ""))
    params = action.get("params", {})
    command = action.get("command", "")
    reward = entry.get("reward_breakdown", {})
    kk_updates = entry.get("kk_updates", [])
    stdout_snippet = entry.get("stdout_snippet", "")
    exec_error = entry.get("exec_error", False)
    parse_error = entry.get("parse_error", False)
    imagination = entry.get("imagination", {})

    param_text = ", ".join(f"{k}={v}" for k, v in params.items()) if params else "(none)"
    updates_text = ", ".join(kk_updates) if kk_updates else "(none)"
    errors = []
    if exec_error:
        errors.append("exec_error")
    if parse_error:
        errors.append("parse_error")
    error_text = ", ".join(errors) if errors else "none"

    sections = [
        f"**Action** tool={tool} WHAT={options[0]} HOW={options[1]} WHO(=WHERE)={options[2]}",
        f"- params: {param_text}",
        f"- command: `{command}`",
        f"- reward: {_format_reward(reward)}",
        f"- kk_updates: {updates_text}",
        f"- errors: {error_text}",
        f"- stdout_snippet: `{stdout_snippet}`" if stdout_snippet else "- stdout_snippet: (none)",
        f"- {_format_imagination(imagination)}",
    ]
    return "\n".join(sections)


st.set_page_config(page_title="Pentesting RL MVP", layout="wide")
st.title("Creative RL Pentesting Agent (MVP)")

run_root = st.sidebar.text_input("runs 디렉터리", value="runs")

with st.sidebar.expander("Target", expanded=True):
    base_url = st.text_input("Target base_url", value="http://127.0.0.1:8080")
    steps = st.number_input("Max steps", min_value=1, max_value=200, value=5)
    tool_name = st.selectbox(
        "Tool",
        [
            "nmap",
            "http-headers",
            "http-fetch",
            "robots-sitemap",
            "html-crawler",
            "dir-enum",
            "hint-scanner",
            "stateful-http",
            "param-influence",
            "auto",
        ],
    )

with st.sidebar.expander("Imagination / Prophecy", expanded=False):
    enable_prophecy = st.checkbox("Enable prophecy model", value=True)
    enable_imagination = st.checkbox("Enable imagination rollouts", value=False)
    rollouts = st.number_input("Rollout count", min_value=1, max_value=10, value=3)

with st.sidebar.expander("Reward flags", expanded=False):
    enable_cost = st.checkbox("Reward: cost", value=True)
    enable_infogain = st.checkbox("Reward: infogain", value=False)
    enable_prophecy_reward = st.checkbox("Reward: prophecy", value=True)
    enable_novelty = st.checkbox("Reward: novelty", value=False)

if "run_thread" not in st.session_state:
    st.session_state.run_thread = None
if "stop_event" not in st.session_state:
    st.session_state.stop_event = threading.Event()
if "active_run_id" not in st.session_state:
    st.session_state.active_run_id = None

tab_run, tab_monitor, tab_history = st.tabs(["Run", "Monitor", "History"])

with tab_run:
    if st.button("Run start"):
        target = parse_base_url(base_url)
        dmp = DecisionMakingProcess(
            config=DMPConfig(max_steps=int(steps) + 1, tool_name=tool_name)
        )
        dmp.config.reward_flags.enable_cost = enable_cost
        dmp.config.reward_flags.enable_infogain = enable_infogain
        dmp.config.reward_flags.enable_prophecy = enable_prophecy_reward
        dmp.config.reward_flags.enable_novelty = enable_novelty
        dmp.config.prophecy_enabled = enable_prophecy
        dmp.config.imagination_enabled = enable_imagination
        dmp.config.imagination_rollouts = int(rollouts)

        port_list = str(target.port)
        dmp.knowledge.update_many(
            {
                "PORT_LIST": [port_list],
                "Port_Spec": [port_list],
                "TARGET_IP": [target.host],
                "Target_IP": [target.host],
                "PATH_HINT": [target.path],
            }
        )
        if tool_name in {"nmap", "auto"}:
            dmp.policy.set_policy("nmap", build_demo_policy([target.port]))
        dmp.config.target_ip = target.host
        executor = nmap_executor if tool_name == "nmap" else tool_aware_executor

        session = RunSession(
            run_root=run_root,
            target={"base_url": target.base_url, "ip": target.host, "ports": [target.port]},
            environment={"docker": True},
        )
        st.session_state.active_run_id = session.run_id
        st.session_state.stop_event.clear()
        thread = threading.Thread(
            target=_run_loop,
            args=(dmp, int(steps), executor, session, st.session_state.stop_event),
        )
        thread.start()
        st.session_state.run_thread = thread

    if st.button("Run stop"):
        st.session_state.stop_event.set()
        thread = st.session_state.run_thread
        if thread and thread.is_alive():
            thread.join(timeout=2)

    if st.button("Refresh"):
        _safe_rerun()

with tab_monitor:
    st.subheader("Active run")
    if st.session_state.active_run_id:
        st.write(f"run_id: {st.session_state.active_run_id}")
    else:
        st.info("Active run 없음.")
    thread = st.session_state.run_thread
    if thread and thread.is_alive():
        st.success("Run thread: running")
    else:
        st.warning("Run thread: idle")

    st.subheader("Live log (formatted)")
    auto_refresh = st.checkbox("Auto refresh", value=True, key="monitor_autorefresh")
    refresh_interval = st.number_input(
        "Refresh interval (sec)", min_value=0.5, max_value=5.0, value=1.0, step=0.5
    )

    run_root_path = Path(run_root)
    run_root_path.mkdir(parents=True, exist_ok=True)
    run_dirs = sorted([p for p in run_root_path.iterdir() if p.is_dir()], reverse=True)
    latest_run = run_root_path / run_dirs[0].name if run_dirs else None
    if latest_run and latest_run.exists():
        runlog = _load_runlog(latest_run)
        if runlog:
            latest_entries = runlog[-5:]
            for entry in latest_entries:
                st.markdown(_format_runlog_entry(entry))
                st.divider()
        else:
            st.info("runlog.jsonl이 아직 없습니다.")
    else:
        st.info("run 디렉터리가 없습니다.")

    if auto_refresh:
        time.sleep(float(refresh_interval))
        _safe_rerun()

with tab_history:
    run_root_path = Path(run_root)
    run_root_path.mkdir(parents=True, exist_ok=True)
    run_dirs = sorted([p for p in run_root_path.iterdir() if p.is_dir()], reverse=True)
    run_ids = [p.name for p in run_dirs]
    selected = st.selectbox("Runs", options=run_ids, index=0 if run_ids else None)

    if selected:
        run_dir = run_root_path / selected
        report = _load_report(run_dir)
        runlog = _load_runlog(run_dir)

        st.subheader("Report summary")
        if report:
            st.json(report.get("summary", {}))
            st.write(f"steps_count: {report.get('steps_count')}")
            st.write(f"findings: {len(report.get('findings', []))}")
        else:
            st.warning("report.json not found yet.")

        st.subheader("Runlog (최근 20개, formatted)")
        if runlog:
            for entry in runlog[-20:]:
                st.markdown(_format_runlog_entry(entry))
                st.divider()
        else:
            st.info("runlog.jsonl이 아직 없습니다.")

        with st.expander("Raw runlog JSON"):
            if runlog:
                st.json(runlog[-20:])
            else:
                st.info("runlog.jsonl이 아직 없습니다.")

        st.subheader("Findings")
        if report and report.get("findings"):
            st.json(report["findings"])
        else:
            st.info("candidate findings 없음.")
