"""Knowledge storage and encoding utilities."""
from __future__ import annotations

from dataclasses import dataclass, field
from typing import Dict, Iterable, List, Set


# Fixed KK definitions aligned with the design document.
#
# Legacy camel-case KK는 기존 코드와의 호환성을 위해 유지하고, 새로운
# 대문자 KK는 YAML 사양(Action space/knowledge_keys)과 1:1 매핑된다.
FIXED_KK: List[str] = [
    # Legacy/compat
    "Target_IP",
    "Port_Spec",
    "Script_Set",
    "Timing",
    "Retry",
    "Timeout",
    # Expanded KK spec
    "TARGET_IP",
    "PORT_LIST",
    "TOP_PORTS",
    "SCRIPT_SET",
    "MAX_RETRIES",
    "HOST_TIMEOUT",
    "SCAN_DELAY",
    "MIN_RATE",
    "MAX_RATE",
    "VER_INTENSITY",
    # Observations
    "Open_Ports",
    "Closed_Ports",
    "Filtered_Ports",
    "Services",
    "Service_Versions",
    "Script_Output",
    "HTTP_ROBOTS_FOUND",
    "HTTP_ROBOTS_HAS_DISALLOW",
    "HTTP_STATUS_302",
    "HTTP_HEADER_LOCATION_PRESENT",
    "HTTP_HEADER_LOCATION",
    "HTTP_HEADER_XNEXT_PRESENT",
    "HTTP_HEADER_XNEXT",
    "PATH_HINT",
    "FLAG_FOUND",
    "PATH_SEEN_BUCKET_0",
    "PATH_SEEN_BUCKET_1",
    "PATH_SEEN_BUCKET_2",
    "PATH_SEEN_BUCKET_3",
    "PATH_SEEN_BUCKET_4",
    "PATH_SEEN_BUCKET_5",
    "PATH_SEEN_BUCKET_6",
    "PATH_SEEN_BUCKET_7",
    "Host_Status",
    "Host_OS",
    "Flag",
    "Errors",
    "RAW_XML",
    "RAW_XML_KV",
    "RAW_NOTES",
]


@dataclass
class KnowledgeStorage:
    """Dictionary-like storage keyed by KK with list values."""

    store: Dict[str, List[str]] = field(default_factory=dict)

    def __post_init__(self) -> None:
        for key in FIXED_KK:
            self.store.setdefault(key, [])

    def reset(self) -> None:
        """Clear all KV lists, preserving KK structure."""
        for key in FIXED_KK:
            self.store[key] = []

    def append(self, key: str, value: str) -> bool:
        """Append a value to a KK list if it is new.

        Returns True if the storage was updated, False otherwise.
        """
        if key not in self.store:
            raise KeyError(f"Unknown KK: {key}")
        if value in self.store[key]:
            return False
        self.store[key].append(value)
        return True

    def update_many(self, mapping: Dict[str, Iterable[str]]) -> Set[str]:
        """Update multiple KK entries, returning the KK that received new data."""
        updated, _ = self.update_many_with_values(mapping)
        return updated

    def update_many_with_values(
        self, mapping: Dict[str, Iterable[str]]
    ) -> tuple[Set[str], Dict[str, List[str]]]:
        """Update multiple KK entries and return updated keys with their new values."""

        updated: Set[str] = set()
        new_values: Dict[str, List[str]] = {}
        for key, values in mapping.items():
            for value in values:
                if self.append(key, value):
                    updated.add(key)
                    new_values.setdefault(key, []).append(value)
        return updated, new_values

    def get_updates_vector(self, updated_keys: Iterable[str]) -> List[int]:
        """Encode updated KK list as a multi-hot vector ordered by FIXED_KK."""
        update_set = set(updated_keys)
        return [1 if key in update_set else 0 for key in FIXED_KK]


class KKEncoder:
    """Utility for encoding KK updates into a fixed-size vector."""

    def __init__(self, kk_list: Iterable[str] = FIXED_KK) -> None:
        self.kk_list: List[str] = list(kk_list)
        self.index: Dict[str, int] = {k: i for i, k in enumerate(self.kk_list)}

    def encode(self, updated_keys: Iterable[str]) -> List[int]:
        vec = [0] * len(self.kk_list)
        for key in updated_keys:
            if key in self.index:
                vec[self.index[key]] = 1
        return vec

    def size(self) -> int:
        return len(self.kk_list)
