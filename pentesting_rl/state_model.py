"""State summarization helpers for reporting/metrics."""
from __future__ import annotations

import hashlib
import json
from typing import Dict, Iterable, List, Tuple


PATH_KEYS = {
    "PATH_HINT",
    "LINK_FOUND",
    "FORM_ACTION",
    "SCRIPT_SRC",
    "JS_ENDPOINT",
    "ROBOTS_DISALLOW",
    "ROBOTS_ALLOW",
    "SITEMAP_URL",
}


def estimate_info_gain(
    transition: Dict[str, object],
    seen_paths: set[str],
    seen_params: set[str],
    seen_cookies: set[str],
) -> Tuple[int, List[str], List[str], List[str]]:
    updated_kk = transition.get("s_t", {}).get("updated_kk", []) or []
    kk_gain = len(updated_kk)
    updates_detail = transition.get("updates_detail", {}) or {}

    new_paths = _collect_new_values(updates_detail, PATH_KEYS, seen_paths)
    new_params = _collect_new_values(updates_detail, {"PARAM_DETECTED"}, seen_params)
    new_cookies = _collect_new_values(updates_detail, {"COOKIE_SEEN", "HTTP_SET_COOKIE"}, seen_cookies)
    gain = kk_gain + len(new_paths) + len(new_params) + len(new_cookies)
    return gain, new_paths, new_params, new_cookies


def state_signature(
    history: List[Dict[str, object]],
    end_index: int,
    window: int = 5,
) -> Tuple[str, Dict[str, object]]:
    start = max(0, end_index - window + 1)
    slice_history = history[start : end_index + 1]
    status_hist: Dict[str, int] = {}
    redirect_max = 0
    paths: set[str] = set()
    params: set[str] = set()
    cookies: set[str] = set()
    headers: set[str] = set()
    blocked = False
    scope_violation = False

    for transition in slice_history:
        updates_detail = transition.get("updates_detail", {}) or {}
        for key in PATH_KEYS:
            for value in updates_detail.get(key, []) or []:
                paths.add(str(value))
        for value in updates_detail.get("PARAM_DETECTED", []) or []:
            params.add(str(value))
        for value in updates_detail.get("COOKIE_SEEN", []) or []:
            cookies.add(str(value))
        for value in updates_detail.get("HTTP_SET_COOKIE", []) or []:
            cookie_name = str(value).split("=", 1)[0].strip()
            if cookie_name:
                cookies.add(cookie_name)
        for value in updates_detail.get("HEADER_PRESENT", []) or []:
            headers.add(str(value))
        for value in updates_detail.get("HTTP_STATUS_CODE", []) or []:
            code = str(value)
            status_hist[code] = status_hist.get(code, 0) + 1
        for value in updates_detail.get("REDIRECT_CHAIN_DEPTH", []) or []:
            try:
                redirect_max = max(redirect_max, int(value))
            except (TypeError, ValueError):
                continue

        safety = transition.get("s_t", {}).get("safety", {}) or {}
        if safety.get("blocked"):
            blocked = True
        if safety.get("scope_violation"):
            scope_violation = True

    summary = {
        "window": window,
        "status_hist": status_hist,
        "redirect_max": redirect_max,
        "path_count": len(paths),
        "param_count": len(params),
        "cookie_count": len(cookies),
        "header_count": len(headers),
        "blocked": blocked,
        "scope_violation": scope_violation,
        "path_sample": _sample_sorted(paths, 5),
        "param_sample": _sample_sorted(params, 5),
        "cookie_sample": _sample_sorted(cookies, 5),
    }
    payload = json.dumps(
        {
            "status_hist": status_hist,
            "redirect_max": redirect_max,
            "path_count": len(paths),
            "param_count": len(params),
            "cookie_count": len(cookies),
            "header_count": len(headers),
            "blocked": blocked,
            "scope_violation": scope_violation,
            "path_sample": summary["path_sample"],
            "param_sample": summary["param_sample"],
            "cookie_sample": summary["cookie_sample"],
        },
        sort_keys=True,
        separators=(",", ":"),
    )
    digest = hashlib.sha1(payload.encode("utf-8")).hexdigest()[:12]
    return digest, summary


def extract_step_paths(transition: Dict[str, object]) -> List[str]:
    updates_detail = transition.get("updates_detail", {}) or {}
    paths: List[str] = []
    for key in PATH_KEYS:
        for value in updates_detail.get(key, []) or []:
            value_str = str(value)
            if value_str not in paths:
                paths.append(value_str)
    return paths


def _collect_new_values(
    updates_detail: Dict[str, object],
    keys: Iterable[str],
    seen: set[str],
) -> List[str]:
    new_values: List[str] = []
    for key in keys:
        for value in updates_detail.get(key, []) or []:
            value_str = str(value)
            if value_str in seen:
                continue
            seen.add(value_str)
            new_values.append(value_str)
    return new_values


def _sample_sorted(values: Iterable[str], limit: int) -> List[str]:
    items = sorted(values)
    return items[:limit]
