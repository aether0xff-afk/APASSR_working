"""Lightweight prophecy model approximating the transformer design."""
from __future__ import annotations

import math
import pathlib
import sys
from dataclasses import dataclass, field
from typing import Dict, List, Sequence, Tuple

if __package__ in {None, ""}:
    sys.path.append(str(pathlib.Path(__file__).resolve().parent.parent))

from pentesting_rl.knowledge import FIXED_KK


@dataclass
class ProphecyState:
    history: List[Tuple[List[int], Tuple[str, str, str], List[int], bool]] = field(
        default_factory=list
    )


class ProphecyModel:
    """Online multi-label predictor used for intrinsic rewards.

    This is a lightweight placeholder for a causal Transformer; it tracks
    smoothed probabilities of KK updates and errors based on historical counts
    to keep dependencies minimal while providing the required interfaces.
    """

    def __init__(self, kk_count: int | None = None, lambda_err: float = 0.5) -> None:
        self.kk_count = kk_count or len(FIXED_KK)
        self.lambda_err = lambda_err
        self.kk_counts = [1.0] * self.kk_count
        self.kk_totals = [2.0] * self.kk_count  # start at 0.5 prob
        self.err_counts = 1.0
        self.err_total = 2.0

    def predict(self, history: Sequence[Tuple[List[int], bool]]) -> Tuple[List[float], float]:
        """Return KK update probabilities and error probability."""
        kk_probs = [c / t for c, t in zip(self.kk_counts, self.kk_totals)]
        err_prob = self.err_counts / self.err_total
        return kk_probs, err_prob

    def update(
        self, target_vec: List[int], error_flag: bool
    ) -> Tuple[float, List[float], float]:
        """Update probability estimates and compute BCE loss."""
        kk_probs, err_prob = self.predict([])
        kk_loss = self._bce_loss(target_vec, kk_probs)
        err_loss = self._bce_single(int(error_flag), err_prob)

        # Update counts (online Bayesian smoothing)
        for i, target in enumerate(target_vec):
            self.kk_totals[i] += 1
            self.kk_counts[i] += target
        self.err_total += 1
        self.err_counts += int(error_flag)

        total_loss = kk_loss + self.lambda_err * err_loss
        return total_loss, kk_probs, err_prob

    @staticmethod
    def _bce_loss(target_vec: List[int], pred_vec: List[float]) -> float:
        eps = 1e-7
        loss = 0.0
        for t, p in zip(target_vec, pred_vec):
            p = min(max(p, eps), 1 - eps)
            loss += -t * math.log(p) - (1 - t) * math.log(1 - p)
        return loss / len(target_vec)

    @staticmethod
    def _bce_single(target: int, prob: float) -> float:
        eps = 1e-7
        prob = min(max(prob, eps), 1 - eps)
        return -target * math.log(prob) - (1 - target) * math.log(1 - prob)
