"""Learnable policy for selecting nmap command slots."""
from __future__ import annotations

import math
import random
from dataclasses import dataclass, field
from typing import Dict, Iterable, List, Sequence, Tuple


@dataclass
class PolicyOption:
    name: str
    weight: float
    parameters: Dict[str, str] | None = None  # Ordered args or KK placeholders


@dataclass
class LearnablePolicy:
    """Independent policies for WHAT (A), HOW (B), WHERE (C)."""

    policy_a: List[PolicyOption] = field(default_factory=list)
    policy_b: List[PolicyOption] = field(default_factory=list)
    policy_c: List[PolicyOption] = field(default_factory=list)

    def __post_init__(self) -> None:
        if not self.policy_a:
            self.policy_a = self._build_options(
                "A",
                [
                    "",
                    "-sS",
                    "-sT",
                    "-sU",
                    "-sA",
                    "-sN",
                    "-sF",
                    "-sX",
                    "-sW",
                    "-sM",
                    "-sn",
                    "-sL",
                    "-sV",
                    "-O",
                    "-sC",
                    "--script {SCRIPT_SET}",
                    "-sS -sV",
                    "-sS -sV -O",
                    "-sU -sV",
                    "-A",
                    "-sS -sC -sV",
                    "-sS -sV --script http-title,banner",
                    "-sS -sV --script ssl-enum-ciphers,default",
                    "--script all",
                    "--script default,safe",
                    "--script auth",
                    "--script brute",
                    "--script discovery",
                    "--script version",
                    "--script vuln",
                    "--script exploit",
                    "--script dos",
                    "--script broadcast",
                    "--script external",
                    "--script fuzzer",
                    "--script intrusive",
                    "--script malware",
                    "--script auth,brute,default,discovery,version,vuln",
                    "-sS --traceroute",
                    "-sS --data-length 25",
                ],
                base_weight=1.0,
            )
        if not self.policy_b:
            self.policy_b = self._build_options(
                "B",
                [
                    "",
                    "-T0",
                    "-T1",
                    "-T2",
                    "-T3",
                    "-T4",
                    "-T5",
                    "-Pn",
                    "-n",
                    "--max-retries {MAX_RETRIES}",
                    "--host-timeout {HOST_TIMEOUT}",
                    "--scan-delay {SCAN_DELAY}",
                    "--min-rate {MIN_RATE}",
                    "--max-rate {MAX_RATE}",
                    "--version-intensity {VER_INTENSITY}",
                    "--version-all",
                    "-T4 --max-retries {MAX_RETRIES}",
                    "-T3 --max-rate {MAX_RATE}",
                    "-T1 --scan-delay {SCAN_DELAY} --max-retries {MAX_RETRIES}",
                    "-T5 --min-rate {MIN_RATE} --version-all",
                ],
                base_weight=1.0,
            )
        if not self.policy_c:
            self.policy_c = self._build_options(
                "C",
                [
                    "-p {PORT_LIST}",
                    "-p-",
                    "-F",
                    "--top-ports {TOP_PORTS}",
                    "--exclude-ports {PORT_LIST} -p-",
                    "-p 80,443,8080",
                    "-p 21,22,25,53,110,143,389,3306,5432,6379,8080",
                    "-p 8000,8008,8443,8888,9000-9001",
                    "-p 1-1024",
                    "-p 1-65535",
                ],
                base_weight=1.0,
            )

    def sample(self) -> Tuple[PolicyOption, PolicyOption, PolicyOption]:
        return (
            self._sample_from(self.policy_a),
            self._sample_from(self.policy_b),
            self._sample_from(self.policy_c),
        )

    def _sample_from(self, options: Sequence[PolicyOption]) -> PolicyOption:
        total = sum(opt.weight for opt in options)
        r = random.random() * total
        cumulative = 0.0
        for opt in options:
            cumulative += opt.weight
            if r <= cumulative:
                return opt
        return options[-1]

    def update(self, reward: float, chosen: Tuple[PolicyOption, PolicyOption, PolicyOption]) -> None:
        """Update weights using the sigmoid rule then renormalize."""
        for opt in chosen:
            opt.weight = self._sigmoid(opt.weight * reward)
        self._renormalize()

    def _renormalize(self) -> None:
        for options in (self.policy_a, self.policy_b, self.policy_c):
            total = sum(opt.weight for opt in options)
            if total == 0:
                for opt in options:
                    opt.weight = 1.0 / len(options)
                continue
            for opt in options:
                opt.weight = opt.weight / total

    def set_uniform_weights(self) -> None:
        for options in (self.policy_a, self.policy_b, self.policy_c):
            if not options:
                continue
            uniform = 1.0 / len(options)
            for opt in options:
                opt.weight = uniform

    @staticmethod
    def _sigmoid(x: float) -> float:
        try:
            return 1 / (1 + math.exp(-x))
        except OverflowError:
            return 0.0 if x < 0 else 1.0

    def _build_options(self, prefix: str, values: Iterable[str], base_weight: float) -> List[PolicyOption]:
        options: List[PolicyOption] = []
        for idx, value in enumerate(values):
            name = f"{prefix}{idx:02d}"
            options.append(PolicyOption(name, base_weight, {"VALUE": value}))
        return options

    def describe(self) -> Dict[str, List[Tuple[str, float]]]:
        return {
            "A": [(opt.name, opt.weight) for opt in self.policy_a],
            "B": [(opt.name, opt.weight) for opt in self.policy_b],
            "C": [(opt.name, opt.weight) for opt in self.policy_c],
        }


@dataclass
class ToolPolicyManager:
    """Policy table per tool plus a top-level tool selector."""

    tool_policy: List[PolicyOption] = field(default_factory=list)
    policies: Dict[str, LearnablePolicy] = field(default_factory=dict)

    def __post_init__(self) -> None:
        if not self.tool_policy:
            tool_names = list(self.policies.keys()) or ["nmap", "http-headers"]
            self.tool_policy = [
                PolicyOption(name=tool, weight=1.0, parameters={"VALUE": tool})
                for tool in tool_names
            ]
        if not self.policies:
            for tool in (opt.name for opt in self.tool_policy):
                self.policies[tool] = self._default_policy_for(tool)

    def sample(self) -> Tuple[str, Tuple[PolicyOption, PolicyOption, PolicyOption]]:
        tool_option = self._sample_from(self.tool_policy)
        tool_name = tool_option.name
        policy = self.policies[tool_name]
        return tool_name, policy.sample()

    def update(
        self,
        reward: float,
        tool_name: str,
        chosen: Tuple[PolicyOption, PolicyOption, PolicyOption],
    ) -> None:
        tool_option = self._find_tool_option(tool_name)
        if tool_option is not None:
            tool_option.weight = self._sigmoid(tool_option.weight * reward)
            self._renormalize_tools()
        self.policies[tool_name].update(reward, chosen)

    def set_policy(self, tool_name: str, policy: LearnablePolicy) -> None:
        self.policies[tool_name] = policy
        if not any(opt.name == tool_name for opt in self.tool_policy):
            self.tool_policy.append(PolicyOption(tool_name, 1.0, {"VALUE": tool_name}))
            self._renormalize_tools()

    def set_uniform_weights(self, tool_name: str | None = None) -> None:
        if tool_name:
            self.policies[tool_name].set_uniform_weights()
            return
        for policy in self.policies.values():
            policy.set_uniform_weights()
        uniform = 1.0 / len(self.tool_policy) if self.tool_policy else 0.0
        for opt in self.tool_policy:
            opt.weight = uniform

    def describe(self, tool_name: str | None = None) -> Dict[str, List[Tuple[str, float]]]:
        if tool_name:
            return self.policies[tool_name].describe()
        return {name: policy.describe() for name, policy in self.policies.items()}

    def _find_tool_option(self, tool_name: str) -> PolicyOption | None:
        for option in self.tool_policy:
            if option.name == tool_name:
                return option
        return None

    def _renormalize_tools(self) -> None:
        total = sum(opt.weight for opt in self.tool_policy)
        if total == 0:
            uniform = 1.0 / len(self.tool_policy)
            for opt in self.tool_policy:
                opt.weight = uniform
            return
        for opt in self.tool_policy:
            opt.weight = opt.weight / total

    def _sample_from(self, options: Sequence[PolicyOption]) -> PolicyOption:
        total = sum(opt.weight for opt in options)
        r = random.random() * total
        cumulative = 0.0
        for opt in options:
            cumulative += opt.weight
            if r <= cumulative:
                return opt
        return options[-1]

    @staticmethod
    def _sigmoid(x: float) -> float:
        try:
            return 1 / (1 + math.exp(-x))
        except OverflowError:
            return 0.0 if x < 0 else 1.0

    @staticmethod
    def _default_policy_for(tool_name: str) -> LearnablePolicy:
        if tool_name == "http-headers":
            return build_http_headers_policy()
        return LearnablePolicy()


def build_http_headers_policy() -> LearnablePolicy:
    return LearnablePolicy(
        policy_a=_build_options(
            "H",
            [
                "-I",
                "-I -L",
                "-I -H 'User-Agent: RLProbe/1.0'",
                "-I -H 'Accept: */*'",
            ],
            base_weight=1.0,
            param_key="CURL_FLAGS",
        ),
        policy_b=_build_options(
            "B",
            [
                "--max-time 5",
                "--max-time 10",
                "--retry 1 --retry-connrefused",
                "--retry 2 --retry-connrefused",
            ],
            base_weight=1.0,
            param_key="CURL_FLAGS",
        ),
        policy_c=_build_options(
            "C",
            [
                "{PATH_HINT}",
                "/robots.txt",
                "/status",
                "/healthz",
                "/login",
            ],
            base_weight=1.0,
            param_key="PATH",
        ),
    )


def _build_options(
    prefix: str, values: Iterable[str], base_weight: float, param_key: str
) -> List[PolicyOption]:
    options: List[PolicyOption] = []
    for idx, value in enumerate(values):
        name = f"{prefix}{idx:02d}"
        options.append(PolicyOption(name, base_weight, {param_key: value}))
    return options
