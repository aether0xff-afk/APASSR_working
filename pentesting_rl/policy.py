"""Learnable policy for selecting nmap command slots."""
from __future__ import annotations

import math
import random
from dataclasses import dataclass, field
from typing import Dict, Iterable, List, Sequence, Tuple


@dataclass
class PolicyOption:
    name: str
    weight: float
    parameters: Dict[str, str] | None = None  # Ordered args or KK placeholders


@dataclass
class LearnablePolicy:
    """Independent policies for WHAT (A), HOW (B), WHERE (C)."""

    policy_a: List[PolicyOption] = field(default_factory=list)
    policy_b: List[PolicyOption] = field(default_factory=list)
    policy_c: List[PolicyOption] = field(default_factory=list)

    def __post_init__(self) -> None:
        if not self.policy_a:
            self.policy_a = self._build_options(
                "A",
                [
                    "",
                    "-sS",
                    "-sT",
                    "-sU",
                    "-sA",
                    "-sN",
                    "-sF",
                    "-sX",
                    "-sW",
                    "-sM",
                    "-sn",
                    "-sL",
                    "-sV",
                    "-O",
                    "-sC",
                    "--script {SCRIPT_SET}",
                    "-sS -sV",
                    "-sS -sV -O",
                    "-sU -sV",
                    "-A",
                    "-sS -sC -sV",
                    "-sS -sV --script http-title,banner",
                    "-sS -sV --script ssl-enum-ciphers,default",
                    "--script all",
                    "--script default,safe",
                    "--script auth",
                    "--script brute",
                    "--script discovery",
                    "--script version",
                    "--script vuln",
                    "--script exploit",
                    "--script dos",
                    "--script broadcast",
                    "--script external",
                    "--script fuzzer",
                    "--script intrusive",
                    "--script malware",
                    "--script auth,brute,default,discovery,version,vuln",
                    "-sS --traceroute",
                    "-sS --data-length 25",
                ],
                base_weight=1.0,
            )
        if not self.policy_b:
            self.policy_b = self._build_options(
                "B",
                [
                    "",
                    "-T0",
                    "-T1",
                    "-T2",
                    "-T3",
                    "-T4",
                    "-T5",
                    "-Pn",
                    "-n",
                    "--max-retries {MAX_RETRIES}",
                    "--host-timeout {HOST_TIMEOUT}",
                    "--scan-delay {SCAN_DELAY}",
                    "--min-rate {MIN_RATE}",
                    "--max-rate {MAX_RATE}",
                    "--version-intensity {VER_INTENSITY}",
                    "--version-all",
                    "-T4 --max-retries {MAX_RETRIES}",
                    "-T3 --max-rate {MAX_RATE}",
                    "-T1 --scan-delay {SCAN_DELAY} --max-retries {MAX_RETRIES}",
                    "-T5 --min-rate {MIN_RATE} --version-all",
                ],
                base_weight=1.0,
            )
        if not self.policy_c:
            self.policy_c = self._build_options(
                "C",
                [
                    "-p {PORT_LIST}",
                    "-p-",
                    "-F",
                    "--top-ports {TOP_PORTS}",
                    "--exclude-ports {PORT_LIST} -p-",
                    "-p 80,443,8080",
                    "-p 21,22,25,53,110,143,389,3306,5432,6379,8080",
                    "-p 8000,8008,8443,8888,9000-9001",
                    "-p 1-1024",
                    "-p 1-65535",
                ],
                base_weight=1.0,
            )

    def sample(self) -> Tuple[PolicyOption, PolicyOption, PolicyOption]:
        return (
            self._sample_from(self.policy_a),
            self._sample_from(self.policy_b),
            self._sample_from(self.policy_c),
        )

    def _sample_from(self, options: Sequence[PolicyOption]) -> PolicyOption:
        total = sum(opt.weight for opt in options)
        r = random.random() * total
        cumulative = 0.0
        for opt in options:
            cumulative += opt.weight
            if r <= cumulative:
                return opt
        return options[-1]

    def update(self, reward: float, chosen: Tuple[PolicyOption, PolicyOption, PolicyOption]) -> None:
        """Update weights using the sigmoid rule then renormalize."""
        for opt in chosen:
            opt.weight = self._sigmoid(opt.weight * reward)
        self._renormalize()

    def _renormalize(self) -> None:
        for options in (self.policy_a, self.policy_b, self.policy_c):
            total = sum(opt.weight for opt in options)
            if total == 0:
                for opt in options:
                    opt.weight = 1.0 / len(options)
                continue
            for opt in options:
                opt.weight = opt.weight / total

    def set_uniform_weights(self) -> None:
        for options in (self.policy_a, self.policy_b, self.policy_c):
            if not options:
                continue
            uniform = 1.0 / len(options)
            for opt in options:
                opt.weight = uniform

    @staticmethod
    def _sigmoid(x: float) -> float:
        try:
            return 1 / (1 + math.exp(-x))
        except OverflowError:
            return 0.0 if x < 0 else 1.0

    def _build_options(self, prefix: str, values: Iterable[str], base_weight: float) -> List[PolicyOption]:
        options: List[PolicyOption] = []
        for idx, value in enumerate(values):
            name = f"{prefix}{idx:02d}"
            options.append(PolicyOption(name, base_weight, {"VALUE": value}))
        return options

    def describe(self) -> Dict[str, List[Tuple[str, float]]]:
        return {
            "A": [(opt.name, opt.weight) for opt in self.policy_a],
            "B": [(opt.name, opt.weight) for opt in self.policy_b],
            "C": [(opt.name, opt.weight) for opt in self.policy_c],
        }
