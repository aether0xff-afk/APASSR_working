"""Simple Tkinter GUI wrapper for running the DMP loop.

This GUI defaults to the built-in demo environment so that a single command can
start the local FLAG HTTP server, run nmap, and display rewards/updates.
"""
from __future__ import annotations

import pathlib
import sys
import threading
import time
import tkinter as tk
from tkinter import messagebox, scrolledtext
from dataclasses import dataclass, field
from typing import Dict, List, Optional

if __package__ in {None, ""}:
    # Enable direct execution via ``python pentesting_rl/gui.py`` by adding the
    # repository root to ``sys.path`` and setting ``__package__`` so relative
    # imports resolve correctly on systems where the module is not installed.
    sys.path.append(str(pathlib.Path(__file__).resolve().parent.parent))
    __package__ = "pentesting_rl"

from pentesting_rl.demo import (
    build_demo_policy,
    build_multistep_policy,
    demo_http_servers,
    multistep_flask_server,
    nmap_executor,
    tool_aware_executor,
)
from pentesting_rl.dmp import DMPConfig, DecisionMakingProcess


@dataclass
class RunMetrics:
    total_steps: int = 0
    knowledge_update_steps: int = 0
    combo_counts: Dict[str, int] = field(default_factory=dict)
    flag_events: List[Dict[str, object]] = field(default_factory=list)
    start_time: float = field(default_factory=time.time)

    def observe(self, transition: Dict[str, object]) -> None:
        self.total_steps += 1
        combo = "/".join(transition.get("a_t", {}).get("options", ("", "", "")))
        self.combo_counts[combo] = self.combo_counts.get(combo, 0) + 1

        if transition.get("s_t", {}).get("updated_kk"):
            self.knowledge_update_steps += 1

        if transition.get("flag_found"):
            self.flag_events.append(
                {
                    "episode": transition.get("meta", {}).get("episode"),
                    "step": transition.get("meta", {}).get("step"),
                    "elapsed": time.time() - self.start_time,
                }
            )

    def update_ratio(self) -> float:
        if not self.total_steps:
            return 0.0
        return self.knowledge_update_steps / self.total_steps

    def diversity(self) -> int:
        return len(self.combo_counts)

    def repeat_distribution(self) -> List[int]:
        return sorted(self.combo_counts.values(), reverse=True)


class DMPGUI:
    def __init__(self, dmp: DecisionMakingProcess, demo_mode: bool = True) -> None:
        self.dmp = dmp
        self.demo_mode = demo_mode
        self._demo_ctx = None
        self._stop_flag = False
        self.root = self._create_root()
        self.root.title("Nmap RL Experiment Runner")

        self.steps_var = tk.StringVar(value=str(self.dmp.config.max_steps))
        self.episodes_var = tk.StringVar(value="3")
        self.target_var = tk.StringVar(value=self.dmp.config.target_ip)
        self.rollouts_var = tk.StringVar(value=str(self.dmp.config.imagination_rollouts))
        self.condition_var = tk.StringVar(value="C2")
        self.prophecy_var = tk.BooleanVar(value=self.dmp.config.prophecy_enabled)
        self.imagination_var = tk.BooleanVar(value=self.dmp.config.imagination_enabled)
        self.scenario_var = tk.StringVar(value="single-flag")
        self.tool_var = tk.StringVar(value=self.dmp.config.tool_name)
        self.demo_var = tk.BooleanVar(value=self.demo_mode)
        self._active_scenario: str | None = None

        if self.demo_mode:
            self.tool_var.set("nmap")

        self._build_controls()
        self._apply_condition()

        self.log_area = scrolledtext.ScrolledText(self.root, height=20)
        self.log_area.pack(fill="both", expand=True, padx=4, pady=4)

        if self.demo_mode:
            self._setup_demo_environment()

        self.root.protocol("WM_DELETE_WINDOW", self._on_close)

    def _build_controls(self) -> None:
        control_frame = tk.LabelFrame(self.root, text="실험 설정", padx=6, pady=6)
        control_frame.pack(fill="x", padx=6, pady=6)

        tk.Label(control_frame, text="Target IP").grid(row=0, column=0, sticky="w")
        tk.Entry(control_frame, textvariable=self.target_var, width=18).grid(
            row=0, column=1, sticky="we", padx=4
        )

        tk.Label(control_frame, text="Episodes").grid(row=0, column=2, sticky="w")
        tk.Entry(control_frame, textvariable=self.episodes_var, width=6).grid(
            row=0, column=3, sticky="we", padx=4
        )

        tk.Label(control_frame, text="Max steps/episode").grid(row=0, column=4, sticky="w")
        tk.Entry(control_frame, textvariable=self.steps_var, width=8).grid(
            row=0, column=5, sticky="we", padx=4
        )

        tk.Label(control_frame, text="Scenario").grid(row=1, column=0, sticky="w")
        tk.OptionMenu(
            control_frame,
            self.scenario_var,
            "single-flag",
            "multistep-single-flag",
        ).grid(row=1, column=1, sticky="w")

        tk.Label(control_frame, text="Tool").grid(row=1, column=2, sticky="w")
        tk.OptionMenu(
            control_frame,
            self.tool_var,
            "nmap",
            "http-headers",
            "http-fetch",
            "robots-sitemap",
            "html-crawler",
            "dir-enum",
            "hint-scanner",
            "stateful-http",
            "param-influence",
            "auto",
        ).grid(row=1, column=3, sticky="w")

        tk.Checkbutton(
            control_frame,
            text="Use demo env",
            variable=self.demo_var,
        ).grid(row=1, column=4, columnspan=2, sticky="w")

        condition_frame = tk.LabelFrame(control_frame, text="Condition")
        condition_frame.grid(row=2, column=0, columnspan=3, sticky="we", pady=4)
        for idx, (code, desc) in enumerate(
            {
                "C0": "Baseline (예언/상상 OFF)",
                "C1": "Prophecy Only (예언 ON)",
                "C2": "Imagination + Prophecy (예언+상상 ON)",
            }.items()
        ):
            tk.Radiobutton(
                condition_frame,
                text=f"{code}: {desc}",
                value=code,
                variable=self.condition_var,
                command=self._apply_condition,
            ).grid(row=idx, column=0, sticky="w")

        toggle_frame = tk.LabelFrame(control_frame, text="세부 토글")
        toggle_frame.grid(row=2, column=3, columnspan=3, sticky="we", padx=4, pady=4)
        tk.Checkbutton(
            toggle_frame,
            text="예언/내재 보상 사용",
            variable=self.prophecy_var,
        ).grid(row=0, column=0, sticky="w")

        tk.Checkbutton(
            toggle_frame,
            text="상상(rollout) 사용",
            variable=self.imagination_var,
        ).grid(row=1, column=0, sticky="w")

        tk.Label(toggle_frame, text="Rollout 수").grid(row=1, column=1, sticky="e")
        tk.Entry(toggle_frame, textvariable=self.rollouts_var, width=6).grid(
            row=1, column=2, sticky="w", padx=2
        )

        action_frame = tk.Frame(self.root)
        action_frame.pack(fill="x", padx=6, pady=4)
        tk.Button(action_frame, text="Run Experiment", command=self.run_experiment).pack(
            side=tk.LEFT, padx=4
        )
        tk.Button(action_frame, text="Stop", command=self.stop_experiment).pack(
            side=tk.LEFT, padx=4
        )

    def log(self, text: str) -> None:
        self.log_area.insert(tk.END, text + "\n")
        self.log_area.see(tk.END)

    def _create_root(self) -> tk.Tk:
        """Create the Tk root window with clearer diagnostics in headless mode."""

        try:
            return tk.Tk()
        except tk.TclError as exc:  # pragma: no cover - platform-specific
            print(
                "GUI를 초기화하지 못했습니다. DISPLAY 환경 변수를 확인하거나 "
                "xvfb-run을 사용해 GUI 세션을 실행하세요.",
                file=sys.stderr,
            )
            print(f"원인: {exc}", file=sys.stderr)
            raise SystemExit(1) from exc

    def _setup_demo_environment(self) -> None:
        """Start the built-in demo HTTP server and configure policies/executor."""

        try:
            scenario = self.scenario_var.get()
            if self._demo_ctx is not None:
                self._demo_ctx.__exit__(None, None, None)
                self._demo_ctx = None
            if scenario == "multistep-single-flag":
                self._demo_ctx = multistep_flask_server()
                port, context, disallow_paths = self._demo_ctx.__enter__()
                paths = ["/robots.txt"] + disallow_paths + [
                    context["gate_path"],
                    context["vault_path"],
                ]
                self.dmp.config.target_ip = "127.0.0.1"
                self.dmp.policy.set_policy("nmap", build_multistep_policy(port, paths))
                self.dmp.executor = nmap_executor
                self.log(f"멀티스텝 Flask 서버가 포트 {port}에서 실행 중입니다.")
            else:
                self._demo_ctx = demo_http_servers()
                primary_port = self._demo_ctx.__enter__()
                self.dmp.config.target_ip = "127.0.0.1"
                self.dmp.policy.set_policy("nmap", build_demo_policy(primary_port))
                self.dmp.executor = nmap_executor
                self.log(f"Demo FLAG 서버가 포트 {primary_port}에서 실행 중입니다.")
            self._active_scenario = scenario
        except Exception as exc:  # pragma: no cover - UI feedback path
            # Ensure any partially created context is torn down so subsequent retries work.
            if self._demo_ctx is not None:
                try:
                    self._demo_ctx.__exit__(None, None, None)
                except Exception:
                    pass
                self._demo_ctx = None

            # Fall back to the dummy executor so the GUI remains usable without nmap.
            self.dmp.executor = self.dmp._dummy_executor
            messagebox.showerror(
                "Demo setup failed",
                "nmap 또는 소켓 바인딩 오류로 데모 환경을 시작하지 못했습니다.\n"
                "PATH/NMAP_PATH 설정과 방화벽을 확인하세요.\n"
                f"원인: {exc}",
            )
            self.log(
                "데모 환경 시작 실패: 안전한 더미 실행기로 계속합니다. "
                "(decoy_port 관련 오류는 이전 데모 캐시에서 발생할 수 있습니다.)"
            )

    def run_experiment(self) -> None:
        use_demo = self.demo_var.get()
        self.dmp.config.tool_name = self.tool_var.get().strip() or "nmap"
        if use_demo:
            if self.dmp.config.tool_name != "nmap":
                messagebox.showinfo(
                    "Demo mode",
                    "Demo 환경에서는 nmap만 사용할 수 있습니다. Tool을 nmap으로 변경합니다.",
                )
                self.dmp.config.tool_name = "nmap"
                self.tool_var.set("nmap")
            if self._active_scenario != self.scenario_var.get():
                self._setup_demo_environment()
        else:
            if self._demo_ctx is not None:
                try:
                    self._demo_ctx.__exit__(None, None, None)
                except Exception:
                    pass
                self._demo_ctx = None
            self._active_scenario = None
            self.dmp.executor = tool_aware_executor

        try:
            steps = int(self.steps_var.get())
        except ValueError:
            steps = self.dmp.config.max_steps

        try:
            episodes = int(self.episodes_var.get())
        except ValueError:
            episodes = 1

        try:
            rollouts = max(1, int(self.rollouts_var.get()))
        except ValueError:
            rollouts = 1

        self.dmp.config.max_steps = steps
        self.dmp.config.target_ip = self.target_var.get().strip() or "127.0.0.1"
        self.dmp.config.prophecy_enabled = self.prophecy_var.get()
        self.dmp.config.imagination_enabled = self.imagination_var.get()
        self.dmp.config.imagination_rollouts = rollouts

        self._stop_flag = False
        thread = threading.Thread(
            target=self._run_experiment_thread, args=(episodes,), daemon=True
        )
        thread.start()

    def stop_experiment(self) -> None:
        self._stop_flag = True
        self.log("[GUI] Stop requested. 현재 스텝 완료 후 중단합니다.")

    def _run_experiment_thread(self, episodes: int) -> None:
        metrics = RunMetrics()
        start_episode = self.dmp.state.episode
        target_episode = start_episode + max(1, episodes)
        self.log(
            f"[RUN] scenario={self.scenario_var.get()}, condition={self.condition_var.get()}, "
            f"episodes={episodes}, steps/episode={self.dmp.config.max_steps}, "
            f"target={self.dmp.config.target_ip}, prophecy={self.dmp.config.prophecy_enabled}, "
            f"imagination={self.dmp.config.imagination_enabled} (rollouts={self.dmp.config.imagination_rollouts}), "
            f"beta={self.dmp.config.beta}, lambda_err={self.dmp.config.lambda_err}, "
            f"lambda_cost={self.dmp.config.lambda_cost}, "
            f"learning={self.dmp.config.learning_enabled}"
        )

        while self.dmp.state.episode < target_episode and not self._stop_flag:
            transition = self.dmp.step()
            metrics.observe(transition)
            self.log(self._format_transition(transition))
            if transition["flag_found"]:
                self.log("FLAG FOUND! 에피소드 리셋 후 계속합니다.")

        self.log(self._format_summary(metrics))

    def _format_transition(self, transition: Dict[str, object]) -> str:
        """Pretty-print a single transition with richer details for the GUI."""

        meta = transition.get("meta", {}) or {}
        episode = meta.get("episode", "?")
        step = meta.get("step", "?")

        options: List[str] = list(transition["a_t"].get("options", ("", "", "")))
        params: Dict[str, str] = transition["a_t"].get("params", {})
        updated: Dict[str, List[str]] = transition.get("updates_detail", {}) or {}

        param_str = ", ".join(f"{k}={v}" for k, v in params.items()) if params else "(none)"
        updates_lines = [f"{kk} -> {', '.join(vals)}" for kk, vals in sorted(updated.items())]
        updates_repr = "; ".join(updates_lines) if updates_lines else "(none)"
        imagination = transition.get("imagination", {}) or {}
        policy_snapshot = transition.get("policy_snapshot", {}) or {}
        knowledge_snapshot = transition.get("knowledge_snapshot", {}) or {}
        policy_lines = []
        for slot, entries in policy_snapshot.items():
            weights = ", ".join(f"{name}={weight:.3f}" for name, weight in entries)
            policy_lines.append(f"{slot}: {weights}")
        policy_repr = " | ".join(policy_lines) if policy_lines else "(none)"
        knowledge_lines = [
            f"{kk} -> {', '.join(values)}"
            for kk, values in sorted(knowledge_snapshot.items())
        ]
        knowledge_repr = "; ".join(knowledge_lines) if knowledge_lines else "(none)"

        ext = transition["a_t"].get("external_reward", 0.0)
        intr = transition["a_t"].get("intrinsic_reward", 0.0)
        total = transition["a_t"].get("reward", 0.0)
        loss = transition["a_t"].get("prophecy_loss", 0.0)
        cost = transition.get("s_t", {}).get("cost", {}) or {}
        penalty = transition["a_t"].get("cost_penalty", 0.0)
        cost_repr = (
            f"requests={cost.get('requests', 0)}, time_ms={cost.get('time_ms', 0)}, "
            f"errors={cost.get('errors', 0)}, penalty={penalty:.3f}"
        )

        lines = [
            f"[E{episode} S{step}] {transition['command']}",
            f"  options: WHAT={options[0]} | HOW={options[1]} | WHERE={options[2]}",
            f"  params: {param_str}",
            f"  updates: {updates_repr}",
            f"  imagination: {imagination}",
            f"  policy_table: {policy_repr}",
            f"  knowledge_store: {knowledge_repr}",
            f"  rewards: total={total:.2f} (ext={ext:.2f}, intr={intr:.2f}, loss={loss:.4f})",
            f"  cost: {cost_repr}",
            f"  flags/error: flag_found={transition['flag_found']}, error={transition['s_t']['error']}",
        ]
        return "\n".join(lines)

    def _format_summary(self, metrics: RunMetrics) -> str:
        first_flag = metrics.flag_events[0] if metrics.flag_events else None
        update_ratio = metrics.update_ratio()
        repeat_counts = metrics.repeat_distribution()

        lines = [
            "[SUMMARY] 실험 종료",
            f"  총 스텝: {metrics.total_steps}",
            f"  고유 (A,B,C) 조합 수: {metrics.diversity()}",
            f"  반복 횟수 분포(top5): {repeat_counts[:5] if repeat_counts else '[]'}",
            f"  지식 업데이트 비율: {update_ratio:.2%}",
            f"  FLAG 발견 수: {len(metrics.flag_events)}",
        ]

        if first_flag:
            lines.append(
                f"  최초 FLAG: episode={first_flag['episode']} step={first_flag['step']} time={first_flag['elapsed']:.2f}s"
            )
        else:
            lines.append("  최초 FLAG: 미발견")
        return "\n".join(lines)

    def _apply_condition(self) -> None:
        condition = self.condition_var.get()
        if condition == "C0":
            self.prophecy_var.set(False)
            self.imagination_var.set(False)
        elif condition == "C1":
            self.prophecy_var.set(True)
            self.imagination_var.set(False)
        else:
            self.prophecy_var.set(True)
            self.imagination_var.set(True)

    def _on_close(self) -> None:
        if self._demo_ctx is not None:
            try:
                self._demo_ctx.__exit__(None, None, None)
            except Exception:
                pass
        self.root.destroy()

    def start(self) -> None:
        self.root.mainloop()


def create_gui(config: Optional[DMPConfig] = None, demo_mode: bool = True) -> DMPGUI:
    dmp = DecisionMakingProcess(executor=None, config=config)
    return DMPGUI(dmp, demo_mode=demo_mode)


if __name__ == "__main__":  # pragma: no cover - manual GUI launch
    gui = create_gui()
    gui.start()
