"""Local demo runner that exercises the DMP against a live HTTP target.

This module starts a single lightweight HTTP server on localhost that hides the
demo FLAG inside response headers rather than the HTML body. It then configures
the decision-making process to run an nmap scan with version detection and HTTP
header/title NSE scripts so the real FLAG surfaces in the XML output and gets
parsed into the knowledge storage. The handler introduces small delays,
redirect bounces, and noisy endpoints so the scan is less trivial while
remaining solvable with nmap alone.

The executor uses the real `nmap` binary and therefore requires it to be
installed in the environment. On Windows, ensure `nmap.exe` is on PATH or set
`NMAP_PATH` to the full executable path.
"""
from __future__ import annotations

import http.server
import json
import os
import platform
import random
import shlex
import shutil
import socketserver
import subprocess
import threading
import pathlib
import sys
import time
from contextlib import contextmanager
from typing import Iterator, List, Tuple

if __package__ in {None, ""}:
    sys.path.append(str(pathlib.Path(__file__).resolve().parent.parent))

from pentesting_rl.dmp import DMPConfig, DecisionMakingProcess
from pentesting_rl.policy import LearnablePolicy, PolicyOption
from pentesting_rl import webtools
from pentesting_rl.run_session import RunSession
from pentesting_rl.target_utils import parse_base_url


FLAG_TEXT = "FLAG{DEMO_TARGET}"
FLAG_HEADER = "X-Backend-Flag"
ALT_FLAG_TEXT = "FLAG{DEMO_ALT_TARGET}"
MULTISTEP_FLAG = "FLAG{MULTISTEP_VAULT}"

# Legacy placeholders kept for compatibility with older demo tooling that may still
# reference decoy-specific globals. They are unused in the current single-target
# demo but prevent NameError crashes on environments reusing cached bytecode.
decoy_port: int | None = None
decoy_server = None


class HarderFlagHandler(http.server.BaseHTTPRequestHandler):
    """HTTP handler that hides the flag in headers with noisy responses."""

    server_version = "MiniDemo/1.6"
    sys_version = ""
    flag_value = FLAG_TEXT
    jitter_range = (0.35, 0.9)

    def log_message(self, format: str, *args) -> None:  # noqa: A003
        # Silence HTTP server logs to keep demo output concise
        return

    def _write_body(
        self, body: bytes, status: int = 200, content_type: str = "text/html", include_flag: bool = True
    ) -> None:
        # Add random latency so fast single probes are less reliable
        time.sleep(random.uniform(*self.jitter_range))
        self.send_response(status)
        self.send_header("Content-Type", content_type)
        self.send_header("Content-Length", str(len(body)))
        self.send_header("X-Diag-Token", "audit:v2")
        if include_flag:
            # Expose the flag only via headers so http-title alone will not capture it.
            self.send_header(FLAG_HEADER, self.flag_value)
        if self.path.startswith("/login"):
            self.send_header("WWW-Authenticate", 'Basic realm="demo"')
        self.end_headers()
        self.wfile.write(body)

    def _maybe_redirect(self) -> bool:
        # Occasionally bounce to another route to force NSE scripts to read headers
        if self.path == "/" and random.random() < 0.25:
            alt = "/portal"
            location = f"http://{self.headers.get('Host', 'localhost')}{alt}"
            self._write_body(b"redirecting", status=302, content_type="text/plain")
            self.send_header("Location", location)
            return True
        return False

    def do_GET(self) -> None:  # noqa: N802
        if self._maybe_redirect():
            return

        routes = {
            "/": b"<html><head><title>Research Portal</title></head><body>Welcome.</body></html>",
            "/portal": b"<html><head><title>Portal</title></head><body>Check headers.</body></html>",
            "/status": b"{\"status\": \"ok\", \"uptime\": 1337}",
            "/login": b"Restricted",  # Will carry a 401
            "/admin/backup": b"nothing to see",
            "/healthz": b"ready",
            "/edge/report": b"pending",
        }

        if self.path == "/login":
            self._write_body(routes[self.path], status=401, content_type="text/plain")
        elif self.path == "/robots.txt":
            body = b"User-agent: *\nDisallow: /admin/backup\nDisallow: /status\nDisallow: /edge\n"
            self._write_body(body, content_type="text/plain")
        elif self.path == "/static/js/app.js":
            body = b"// legacy bundle placeholder\nconsole.log('demo');"
            self._write_body(body, content_type="application/javascript")
        else:
            body = routes.get(self.path)
            if body is None:
                body = b"<html><head><title>Not Found</title></head><body>404</body></html>"
                self._write_body(body, status=404, include_flag=False)
            else:
                self._write_body(body, content_type="text/plain" if self.path.startswith("/status") else "text/html")


class TitleFlagHandler(http.server.BaseHTTPRequestHandler):
    """HTTP handler that embeds the flag in the HTML title."""

    server_version = "AltDemo/1.0"
    sys_version = ""
    flag_value = ALT_FLAG_TEXT

    def log_message(self, format: str, *args) -> None:  # noqa: A003
        return

    def do_GET(self) -> None:  # noqa: N802
        body = (
            "<html><head><title>{flag}</title></head>"
            "<body><h1>Alternate Portal</h1><p>Inspect title.</p></body></html>"
        ).format(flag=self.flag_value)
        body_bytes = body.encode("utf-8")
        self.send_response(200)
        self.send_header("Content-Type", "text/html")
        self.send_header("Content-Length", str(len(body_bytes)))
        self.send_header("X-Alt-Token", "alt:v1")
        self.end_headers()
        self.wfile.write(body_bytes)


class ReusableTCPServer(socketserver.ThreadingMixIn, socketserver.TCPServer):
    """TCP server tuned for quick teardown on Windows/Linux."""

    allow_reuse_address = True
    daemon_threads = True


def _serve_handler(
    handler: type[http.server.BaseHTTPRequestHandler], port: int = 0
) -> Tuple[ReusableTCPServer, int, threading.Thread]:
    server = ReusableTCPServer(("127.0.0.1", port), handler)
    actual_port = server.server_address[1]
    thread = threading.Thread(target=server.serve_forever, daemon=True)
    thread.start()
    return server, actual_port, thread


@contextmanager
def demo_http_servers(port: int = 0) -> Iterator[List[int]]:
    """Run multiple HTTP servers that expose flags via different surfaces."""

    servers: List[ReusableTCPServer] = []
    threads: List[threading.Thread] = []
    ports: List[int] = []
    handlers = [HarderFlagHandler, TitleFlagHandler]
    for handler in handlers:
        try:
            server, actual_port, thread = _serve_handler(handler, port)
        except OSError as exc:
            for existing in servers:
                existing.shutdown()
                existing.server_close()
            for thread_item in threads:
                thread_item.join(timeout=2)
            raise RuntimeError(
                "Failed to bind demo HTTP server. Check firewall/port availability."
            ) from exc
        servers.append(server)
        threads.append(thread)
        ports.append(actual_port)

    try:
        yield ports
    finally:
        for server in servers:
            server.shutdown()
            server.server_close()
        for thread_item in threads:
            thread_item.join(timeout=2)


def _build_multistep_app() -> Tuple[object, dict[str, str], List[str]]:
    try:
        from flask import Flask, Response
    except ImportError as exc:
        raise RuntimeError("flask is required for multistep scenarios") from exc

    app = Flask(__name__)
    disallow_paths = ["/alpha-deny", "/gamma-ghost", "/beta-gate"]
    redirect_path = "/beta-gate"
    gate_token = "gate-42"
    vault_token = "vault-9f1"
    gate_path = f"/gate/{gate_token}"
    vault_path = f"/vault/{vault_token}"
    context = {
        "redirect_path": redirect_path,
        "gate_path": gate_path,
        "vault_path": vault_path,
    }

    @app.after_request
    def _force_local_only(response: Response) -> Response:
        response.headers["X-Scenario"] = "multistep-single-flag"
        return response

    @app.route("/robots.txt")
    def robots() -> Response:
        body = "User-agent: *\n" + "\n".join(f"Disallow: {p}" for p in disallow_paths)
        return Response(body, mimetype="text/plain")

    @app.route("/", defaults={"path": ""})
    @app.route("/<path:path>")
    def route_all(path: str) -> Response:
        full_path = f"/{path}" if path else "/"
        if full_path == redirect_path:
            response = Response("redirecting", status=302, mimetype="text/plain")
            response.headers["Location"] = gate_path
            return response
        if full_path == gate_path:
            response = Response("ok", status=200, mimetype="text/plain")
            response.headers["X-Next"] = vault_path
            return response
        if full_path == vault_path:
            response = Response("vault", status=200, mimetype="text/plain")
            response.headers["X-Vault-Flag"] = MULTISTEP_FLAG
            return response
        if full_path in disallow_paths:
            return Response("decoy", status=200, mimetype="text/plain")
        if full_path == "/status":
            return Response("ok", status=200, mimetype="text/plain")
        return Response("not found", status=404, mimetype="text/plain")

    return app, context, disallow_paths


@contextmanager
def multistep_flask_server(port: int = 0) -> Iterator[Tuple[int, dict[str, str], List[str]]]:
    try:
        from werkzeug.serving import make_server
    except ImportError as exc:
        raise RuntimeError("werkzeug is required for multistep scenarios") from exc

    app, context, disallow_paths = _build_multistep_app()
    server = make_server("127.0.0.1", port, app)
    actual_port = server.server_port
    thread = threading.Thread(target=server.serve_forever, daemon=True)
    thread.start()
    try:
        yield actual_port, context, disallow_paths
    finally:
        server.shutdown()
        thread.join(timeout=2)


def _locate_nmap_binary() -> str:
    """Find an nmap binary, including common Windows install paths."""

    env_path = os.environ.get("NMAP_PATH")
    if env_path:
        return env_path.strip('"')

    # Look for nmap/nmap.exe on PATH first.
    path_hit = shutil.which("nmap") or shutil.which("nmap.exe")
    if path_hit:
        return path_hit

    # Probe common Windows installers so the demo works without manual PATH edits.
    if platform.system() == "Windows":
        program_files = os.environ.get("ProgramFiles", r"C:\\Program Files")
        program_files_x86 = os.environ.get("ProgramFiles(x86)", r"C:\\Program Files (x86)")
        candidates = [
            os.path.join(program_files, "Nmap", "nmap.exe"),
            os.path.join(program_files_x86, "Nmap", "nmap.exe"),
        ]
        for candidate in candidates:
            if os.path.exists(candidate):
                return candidate

    raise RuntimeError(
        "nmap binary not found. Install nmap or set NMAP_PATH to its location."
    )


def nmap_executor(command: str) -> Tuple[str, bool]:
    """Execute an nmap command and return XML plus an error flag."""

    nmap_path = _locate_nmap_binary()

    # Use platform-appropriate tokenization to avoid shell quoting issues on Windows.
    tokens = shlex.split(command, posix=platform.system() != "Windows")
    tokens[0] = nmap_path

    run_kwargs = {
        "shell": False,
        "check": False,
        "capture_output": True,
        "text": True,
    }

    if platform.system() == "Windows":
        # Hide the console window that would otherwise pop for each scan.
        si = subprocess.STARTUPINFO()
        si.dwFlags |= subprocess.STARTF_USESHOWWINDOW
        run_kwargs.update({
            "startupinfo": si,
            "creationflags": subprocess.CREATE_NO_WINDOW,
        })

    completed = subprocess.run(tokens, **run_kwargs)
    xml_output = completed.stdout.strip()
    # Treat non-zero return codes or empty XML as an execution error.
    syntax_error = completed.returncode != 0 or not xml_output
    return xml_output or "<nmaprun></nmaprun>", syntax_error


def generic_executor(command: str) -> Tuple[str, bool]:
    """Execute a generic shell command and return stdout plus an error flag."""

    tokens = shlex.split(command, posix=platform.system() != "Windows")
    completed = subprocess.run(
        tokens,
        shell=False,
        check=False,
        capture_output=True,
        text=True,
    )
    output = completed.stdout.strip()
    syntax_error = completed.returncode != 0
    return output, syntax_error


def tool_aware_executor(command: str) -> Tuple[str, bool]:
    """Dispatch to nmap or generic executor based on the command prefix."""

    tokens = shlex.split(command, posix=platform.system() != "Windows")
    if tokens and tokens[0] == "pytool":
        result = webtools.execute_pytool(tokens)
        output = json.dumps(result, ensure_ascii=True)
        return output, not result.get("ok", True)
    if tokens and tokens[0] == "nmap":
        return nmap_executor(command)
    return generic_executor(command)


def build_demo_policy(ports: List[int]) -> LearnablePolicy:
    """Create a policy with multiple nmap slot choices that target the demo flags.

    The WHAT/HOW/WHERE slots remain independent, so the generated commands will vary
    across steps while still scanning the correct port. All WHAT variants include the
    ``http-headers`` NSE script (often paired with ``http-title``) so the hidden header
    flag surfaces in XML output regardless of which combination is sampled.
    """

    port_list = ",".join(str(port) for port in ports)
    port_spec = f"-p {port_list}"

    return LearnablePolicy(
        policy_a=[
            PolicyOption(
                "VersionHeaders",
                1.2,
                {"WHAT": "-sV --script=http-headers,http-title"},
            ),
            PolicyOption(
                "AggressiveHeaders",
                1.0,
                {"WHAT": "-A --script=http-headers,http-title,banner"},
            ),
            PolicyOption(
                "RobotsHeaders",
                0.9,
                {"WHAT": "-sV --script=http-headers,http-robots.txt,http-title,http-trace"},
            ),
            PolicyOption(
                "NoPingHeaders",
                0.8,
                {"WHAT": "-Pn -sS -sV --script=http-headers,http-title"},
            ),
            PolicyOption(
                "TraceHeaders",
                0.6,
                {"WHAT": "-sS --traceroute --script=http-headers,http-title,http-server-header"},
            ),
        ],
        policy_b=[
            PolicyOption("Polite", 1.0, {"Timing": "-T2", "Retry": "--max-retries 3"}),
            PolicyOption("Normal", 1.0, {"Timing": "-T3"}),
            PolicyOption(
                "Aggressive",
                0.8,
                {"Timing": "-T4", "Timeout": "--host-timeout 15s"},
            ),
            PolicyOption(
                "RetrySweep",
                0.6,
                {"Timing": "-T3", "Retry": "--max-retries 5", "Discover": "--resolve-all"},
            ),
        ],
        policy_c=[
            PolicyOption("TargetsOnly", 1.0, {"Port_Spec": port_spec}),
            PolicyOption("TargetsPlusWeb", 0.8, {"Port_Spec": f"{port_spec},80,8080"}),
            PolicyOption("TargetsTop", 0.6, {"Port_Spec": f"{port_spec} --top-ports 50"}),
        ],
    )


def build_multistep_policy(port: int, paths: List[str]) -> LearnablePolicy:
    port_spec = f"-p {port}"
    path_options = [
        PolicyOption(
            "RobotsPath",
            1.2,
            {
                "Port_Spec": port_spec,
                "Path_Args": "--script-args http-headers.path=/robots.txt,http-robots.txt.path=/robots.txt",
            },
        ),
        PolicyOption(
            "HintPath",
            1.0,
            {
                "Port_Spec": port_spec,
                "Path_Args": "--script-args http-headers.path={PATH_HINT},http-robots.txt.path={PATH_HINT}",
            },
        ),
    ]
    for idx, path in enumerate(paths):
        path_args = (
            f"--script-args http-headers.path={path},http-robots.txt.path={path}"
        )
        path_options.append(
            PolicyOption(f"Path{idx:02d}", 0.6, {"Port_Spec": port_spec, "Path_Args": path_args})
        )

    return LearnablePolicy(
        policy_a=[
            PolicyOption("HeadersRobots", 1.2, {"WHAT": "-sV --script=http-headers,http-robots.txt"}),
            PolicyOption("HeadersOnly", 1.0, {"WHAT": "-sV --script=http-headers"}),
        ],
        policy_b=[
            PolicyOption("Polite", 1.0, {"Timing": "-T2", "Retry": "--max-retries 3"}),
            PolicyOption("Normal", 1.0, {"Timing": "-T3"}),
            PolicyOption("Aggressive", 0.8, {"Timing": "-T4", "Timeout": "--host-timeout 15s"}),
        ],
        policy_c=path_options,
    )


def run_local_demo(
    steps: int = 3,
    run_root: str = "runs",
    environment: dict[str, object] | None = None,
) -> DecisionMakingProcess:
    """Spin up the demo server and run a short DMP episode with real nmap."""

    dmp = DecisionMakingProcess(config=DMPConfig(max_steps=max(steps + 1, 2)))
    environment = environment or {"docker": False}

    transitions = []
    with demo_http_servers() as ports:
        dmp.policy.set_policy("nmap", build_demo_policy(ports))
        dmp.config.target_ip = "127.0.0.1"
        target = {
            "base_url": f"http://{dmp.config.target_ip}:{ports[0]}",
            "ip": dmp.config.target_ip,
            "ports": ports,
        }
        session = RunSession(run_root, target=target, environment=environment)
        session.attach(dmp)
        try:
            for _ in range(steps):
                transitions.append(dmp.step(executor=nmap_executor))
        finally:
            session.finalize(dmp.knowledge.store)
            session.detach(dmp)

    # Preserve the captured transitions even if the internal episode reset after
    # a FLAG was detected during the scan.
    dmp.state.history = transitions
    return dmp


def run_multistep_demo(steps: int = 5) -> DecisionMakingProcess:
    dmp = DecisionMakingProcess(config=DMPConfig(max_steps=max(steps + 1, 2)))
    transitions = []
    with multistep_flask_server() as (port, context, disallow_paths):
        paths = disallow_paths
        dmp.policy.set_policy("nmap", build_multistep_policy(port, paths))
        dmp.config.target_ip = "127.0.0.1"
        for _ in range(steps):
            transitions.append(dmp.step(executor=nmap_executor))
    dmp.state.history = transitions
    return dmp


def run_target_demo(
    target_ip: str,
    ports: List[int],
    steps: int = 3,
    tool_name: str = "nmap",
    run_root: str = "runs",
    environment: dict[str, object] | None = None,
    base_url: str | None = None,
    path_hint: str | None = None,
) -> DecisionMakingProcess:
    """Run the DMP against a user-provided target without starting local servers."""

    dmp = DecisionMakingProcess(
        config=DMPConfig(max_steps=max(steps + 1, 2), tool_name=tool_name)
    )
    environment = environment or {"docker": True}
    port_list = ",".join(str(port) for port in ports)
    dmp.knowledge.update_many(
        {
            "PORT_LIST": [port_list],
            "Port_Spec": [port_list],
            "TARGET_IP": [target_ip],
            "Target_IP": [target_ip],
        }
    )
    if path_hint:
        dmp.knowledge.update_many({"PATH_HINT": [path_hint]})
    if tool_name in {"nmap", "auto"}:
        dmp.policy.set_policy("nmap", build_demo_policy(ports))
    dmp.config.target_ip = target_ip

    transitions = []
    executor = nmap_executor if tool_name == "nmap" else tool_aware_executor
    target = {
        "base_url": base_url or f"http://{target_ip}:{ports[0]}",
        "ip": target_ip,
        "ports": ports,
    }
    session = RunSession(run_root, target=target, environment=environment)
    session.attach(dmp)
    try:
        for _ in range(steps):
            transitions.append(dmp.step(executor=executor))
    finally:
        session.finalize(dmp.knowledge.store)
        session.detach(dmp)
        dmp.last_run_id = session.run_id

    dmp.state.history = transitions
    return dmp


def run_target_base_url(
    base_url: str,
    steps: int = 3,
    tool_name: str = "nmap",
    run_root: str = "runs",
    environment: dict[str, object] | None = None,
) -> DecisionMakingProcess:
    target = parse_base_url(base_url)
    dmp = run_target_demo(
        target_ip=target.host,
        ports=[target.port],
        steps=steps,
        tool_name=tool_name,
        run_root=run_root,
        environment=environment,
        base_url=target.base_url,
        path_hint=target.path,
    )
    return dmp


def run_target_base_url(
    base_url: str,
    steps: int = 3,
    tool_name: str = "nmap",
    run_root: str = "runs",
    environment: dict[str, object] | None = None,
) -> DecisionMakingProcess:
    target = parse_base_url(base_url)
    dmp = run_target_demo(
        target_ip=target.host,
        ports=[target.port],
        steps=steps,
        tool_name=tool_name,
        run_root=run_root,
        environment=environment,
        base_url=target.base_url,
        path_hint=target.path,
    )
    return dmp


def summarize_history(history: list[dict[str, object]]) -> dict[str, float | int]:
    total_reward = 0.0
    flag_hits = 0
    combos = set()
    for transition in history:
        action = transition.get("a_t", {})
        reward = action.get("reward")
        if isinstance(reward, (int, float)):
            total_reward += float(reward)
        options = action.get("options")
        if isinstance(options, tuple):
            combos.add("/".join(options))
        if transition.get("flag_found"):
            flag_hits += 1
    steps = len(history)
    avg_reward = total_reward / steps if steps else 0.0
    return {
        "steps": steps,
        "flags": flag_hits,
        "avg_reward": avg_reward,
        "unique_combos": len(combos),
    }


def run_local_comparison(steps: int = 3) -> dict[str, DecisionMakingProcess]:
    """Run both a random baseline and the learnable policy against the demo target."""

    max_steps = max(steps + 1, 2)
    baseline_config = DMPConfig(
        max_steps=max_steps,
        prophecy_enabled=False,
        imagination_enabled=False,
        learning_enabled=False,
    )
    policy_config = DMPConfig(max_steps=max_steps)

    baseline = DecisionMakingProcess(config=baseline_config)
    policy_run = DecisionMakingProcess(config=policy_config)

    baseline_transitions = []
    policy_transitions = []

    with demo_http_servers() as ports:
        baseline.policy.set_policy("nmap", build_demo_policy(ports))
        baseline.policy.set_uniform_weights("nmap")
        policy_run.policy.set_policy("nmap", build_demo_policy(ports))

        baseline.config.target_ip = "127.0.0.1"
        policy_run.config.target_ip = "127.0.0.1"

        for _ in range(steps):
            baseline_transitions.append(baseline.step(executor=nmap_executor))
        for _ in range(steps):
            policy_transitions.append(policy_run.step(executor=nmap_executor))

    baseline.state.history = baseline_transitions
    policy_run.state.history = policy_transitions

    return {"random": baseline, "policy": policy_run}


def main(argv: List[str] | None = None) -> int:
    import argparse

    parser = argparse.ArgumentParser(description="Run local demo scenarios")
    parser.add_argument(
        "--scenario",
        choices=["single-flag", "multistep-single-flag"],
        default="single-flag",
        help="Select the local demo scenario to run",
    )
    parser.add_argument("--steps", type=int, default=3, help="Number of DMP steps")
    args = parser.parse_args(argv)

    if args.scenario == "multistep-single-flag":
        process = run_multistep_demo(steps=args.steps)
    else:
        process = run_local_demo(steps=args.steps)

    print(f"총 {len(process.state.history)} 스텝 실행")
    for entry in process.state.history:
        print(entry)
    return 0


if __name__ == "__main__":
    raise SystemExit(main())
