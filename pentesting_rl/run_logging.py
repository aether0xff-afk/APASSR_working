"""Run logging and report generation utilities."""
from __future__ import annotations

import json
import secrets
import time
from dataclasses import dataclass, field
from pathlib import Path
from typing import Mapping, Sequence

from pentesting_rl.novelty_tokens import extract_top_level_path, summarize_paths_top


_SNIPPET_LIMIT = 500
_BLOB_CHAR_LIMIT = 4096
_BLOB_LINE_LIMIT = 200


class RunIdGenerator:
    @staticmethod
    def generate() -> str:
        timestamp = time.strftime("%Y%m%dT%H%M%SZ", time.gmtime())
        rand = secrets.token_hex(3)
        return f"{timestamp}_{rand}"


@dataclass
class RunMetadata:
    run_id: str
    target: dict[str, object]
    environment: dict[str, object]
    run_dir: Path
    started_at: float
    errors: list[dict[str, object]] = field(default_factory=list)
    findings: list[dict[str, object]] = field(default_factory=list)


class RunWriter:
    def __init__(self, run_root: str | Path, run_id: str | None = None) -> None:
        self.run_id = run_id or RunIdGenerator.generate()
        self.run_dir = Path(run_root) / self.run_id
        self.run_dir.mkdir(parents=True, exist_ok=True)
        self.runlog_path = self.run_dir / "runlog.jsonl"
        self._line_index = 0
        self._prepare_artifacts()

    def _prepare_artifacts(self) -> None:
        for subdir in ("stdout", "stderr", "http", "files"):
            (self.run_dir / "artifacts" / subdir).mkdir(parents=True, exist_ok=True)

    def append_step(self, record: dict[str, object]) -> int:
        runlog_line = self._line_index
        record.setdefault("runlog_line", runlog_line)
        record.setdefault("step_index", runlog_line)
        with self.runlog_path.open("a", encoding="utf-8") as handle:
            handle.write(json.dumps(record, ensure_ascii=True) + "\n")
        self._line_index += 1
        return runlog_line

    def write_text_artifact(
        self, kind: str, step_index: int, content: str
    ) -> tuple[str | None, list[dict[str, object]]]:
        errors: list[dict[str, object]] = []
        if kind not in {"stdout", "stderr", "http"}:
            kind = "files"
        filename = f"step_{step_index:04d}.txt"
        if kind == "http":
            filename = f"step_{step_index:04d}_resp.txt"
        path = self.run_dir / "artifacts" / kind / filename
        try:
            path.write_text(content, encoding="utf-8")
        except OSError as exc:
            errors.append(
                {
                    "type": "artifact_write_failed",
                    "artifact_kind": kind,
                    "path": str(path.relative_to(self.run_dir)),
                    "message": str(exc),
                    "recover": "stored_snippet_only",
                }
            )
            return None, errors
        return str(path.relative_to(self.run_dir)), errors


def should_store_blob(text: str) -> bool:
    if len(text) > _BLOB_CHAR_LIMIT:
        return True
    line_count = text.count("\n") + 1 if text else 0
    return line_count > _BLOB_LINE_LIMIT


def snippet(text: str) -> str:
    if not text:
        return ""
    return text[:_SNIPPET_LIMIT]


def build_summary(steps_count: int, candidate_count: int, duration: float, paths_top: list[str]) -> dict[str, object]:
    return {
        "template": "자동화 에이전트가 대상에 대해 정찰 및 취약점 후보를 수집하고 보고서를 생성함.",
        "facts": {
            "steps": steps_count,
            "candidate_findings": candidate_count,
            "duration_sec": round(duration, 3),
            "unique_paths_top": paths_top,
        },
    }


def collect_paths_top(knowledge: Mapping[str, Sequence[str]]) -> list[str]:
    paths: list[str] = []
    for key in (
        "PATH_HINT",
        "LINK_FOUND",
        "FORM_ACTION",
        "SCRIPT_SRC",
        "JS_ENDPOINT",
        "ROBOTS_DISALLOW",
        "ROBOTS_ALLOW",
        "SITEMAP_URL",
    ):
        paths.extend([str(v) for v in knowledge.get(key, [])])
    return summarize_paths_top(paths)


def build_report(
    metadata: RunMetadata,
    knowledge_final: Mapping[str, Sequence[str]],
    steps_count: int,
    finished_at: float,
    schema_version: str = "0.1.0",
    generator_version: str = "mvp",
) -> dict[str, object]:
    duration = max(0.0, finished_at - metadata.started_at)
    summary = build_summary(
        steps_count,
        len(metadata.findings),
        duration,
        collect_paths_top(knowledge_final),
    )
    return {
        "schema_version": schema_version,
        "generator_version": generator_version,
        "run_id": metadata.run_id,
        "target": metadata.target,
        "environment": metadata.environment,
        "summary": summary,
        "steps_count": steps_count,
        "findings": metadata.findings,
        "knowledge_final": {key: list(values) for key, values in knowledge_final.items()},
        "errors": metadata.errors,
        "started_at": metadata.started_at,
        "finished_at": finished_at,
    }


def write_report(report_path: Path, payload: dict[str, object]) -> None:
    report_path.write_text(json.dumps(payload, indent=2, ensure_ascii=True), encoding="utf-8")

