"""Parser for nmap XML outputs mapped to fixed KK keys."""
from __future__ import annotations

import hashlib
import re
import pathlib
import sys
import xml.etree.ElementTree as ET
from dataclasses import dataclass
from typing import Dict, List, Set

if __package__ in {None, ""}:
    sys.path.append(str(pathlib.Path(__file__).resolve().parent.parent))

from pentesting_rl.knowledge import FIXED_KK, KnowledgeStorage

FLAG_PATTERN = re.compile(r"FLAG\{[^}]{1,128}\}")
ROBOTS_DISALLOW_PATTERN = re.compile(r"Disallow:\s*(/[^\s#]+)", re.IGNORECASE)
HTTP_STATUS_302_PATTERN = re.compile(r"HTTP/\\d\\.\\d\\s+302\\b", re.IGNORECASE)
HEADER_LOCATION_PATTERN = re.compile(r"^Location:\\s*(\\S+)", re.IGNORECASE | re.MULTILINE)
HEADER_XNEXT_PATTERN = re.compile(r"^X-Next:\\s*(\\S+)", re.IGNORECASE | re.MULTILINE)
PATH_PATTERN = re.compile(r"/[A-Za-z0-9._~!$&'()*+,;=:@/%-]{1,128}")
PATH_BUCKET_COUNT = 8


@dataclass
class ParsedResult:
    updates: Set[str]
    error: bool
    new_values: Dict[str, List[str]]


class NmapXMLParser:
    """Map nmap -oX output into the fixed KK set."""

    def __init__(self, storage: KnowledgeStorage) -> None:
        self.storage = storage

    def parse_and_update(self, xml_data: str) -> ParsedResult:
        updates: Dict[str, List[str]] = {key: [] for key in FIXED_KK}
        error = False

        try:
            root = ET.fromstring(xml_data)
        except ET.ParseError:
            updates["Errors"].append("XMLParseError")
            updates["RAW_XML"].append(xml_data)
            error = True
            updated_keys, new_values = self.storage.update_many_with_values(updates)
            return ParsedResult(updated_keys, error, new_values)

        self._extract_host_info(root, updates)
        self._extract_ports(root, updates)
        self._extract_scripts(root, updates)
        self._extract_raw(root, updates, xml_data)

        updated_keys, new_values = self.storage.update_many_with_values(updates)
        return ParsedResult(updated_keys, error, new_values)

    def _extract_host_info(self, root: ET.Element, updates: Dict[str, List[str]]) -> None:
        for host in root.findall("host"):
            status_el = host.find("status")
            if status_el is not None:
                state = status_el.get("state")
                if state:
                    updates["Host_Status"].append(state)
            address_el = host.find("address")
            if address_el is not None:
                addr = address_el.get("addr")
                if addr:
                    updates["Target_IP"].append(addr)
            for osmatch in host.findall("os/osmatch"):
                name = osmatch.get("name")
                if name:
                    updates["Host_OS"].append(name)

    def _extract_ports(self, root: ET.Element, updates: Dict[str, List[str]]) -> None:
        for port_el in root.findall(".//port"):
            portid = port_el.get("portid")
            proto = port_el.get("protocol")
            state_el = port_el.find("state")
            state = state_el.get("state") if state_el is not None else None
            service_el = port_el.find("service")
            service_name = service_el.get("name") if service_el is not None else None
            service_ver = service_el.get("version") if service_el is not None else None

            port_repr = f"{proto}/{portid}" if proto and portid else portid or ""
            if state == "open":
                updates["Open_Ports"].append(port_repr)
            elif state == "closed":
                updates["Closed_Ports"].append(port_repr)
            elif state:
                updates["Filtered_Ports"].append(port_repr)

            if service_name:
                updates["Services"].append(f"{port_repr}:{service_name}")
            if service_ver:
                updates["Service_Versions"].append(f"{port_repr}:{service_ver}")

    def _extract_scripts(self, root: ET.Element, updates: Dict[str, List[str]]) -> None:
        for script in root.findall(".//script"):
            output = script.get("output")
            if output:
                updates["Script_Output"].append(output)
                for match in FLAG_PATTERN.findall(output):
                    updates["Flag"].append(match)
                    updates["FLAG_FOUND"].append(match)
                if "robots" in output.lower():
                    updates["HTTP_ROBOTS_FOUND"].append("true")
                disallows = ROBOTS_DISALLOW_PATTERN.findall(output)
                if disallows:
                    updates["HTTP_ROBOTS_HAS_DISALLOW"].append("true")
                    for path in disallows:
                        self._record_path_bucket(path, updates)
                        updates["PATH_HINT"].append(path)
                if HTTP_STATUS_302_PATTERN.search(output):
                    updates["HTTP_STATUS_302"].append("true")
                location_matches = HEADER_LOCATION_PATTERN.findall(output)
                if location_matches:
                    updates["HTTP_HEADER_LOCATION_PRESENT"].append("true")
                    for value in location_matches:
                        self._record_path_bucket(value, updates)
                        updates["HTTP_HEADER_LOCATION"].append(value)
                        updates["PATH_HINT"].append(value)
                xnext_matches = HEADER_XNEXT_PATTERN.findall(output)
                if xnext_matches:
                    updates["HTTP_HEADER_XNEXT_PRESENT"].append("true")
                    for value in xnext_matches:
                        self._record_path_bucket(value, updates)
                        updates["HTTP_HEADER_XNEXT"].append(value)
                        updates["PATH_HINT"].append(value)
                for path in PATH_PATTERN.findall(output):
                    self._record_path_bucket(path, updates)

    def _extract_raw(self, root: ET.Element, updates: Dict[str, List[str]], xml_data: str) -> None:
        updates["RAW_XML"].append(xml_data)
        kv_dump: List[str] = []
        for tag in ("status", "address", "hostname", "service", "script"):
            for elem in root.findall(f".//{tag}"):
                kv_dump.append(ET.tostring(elem, encoding="unicode"))
        updates["RAW_XML_KV"].extend(kv_dump)
        notes = FLAG_PATTERN.findall(xml_data)
        updates["RAW_NOTES"].extend(notes)
        for match in notes:
            updates["FLAG_FOUND"].append(match)

    def _record_path_bucket(self, value: str, updates: Dict[str, List[str]]) -> None:
        path = value.strip()
        if not path.startswith("/"):
            match = PATH_PATTERN.search(path)
            if not match:
                return
            path = match.group(0)
        digest = hashlib.sha256(path.encode("utf-8")).hexdigest()
        bucket = int(digest[:8], 16) % PATH_BUCKET_COUNT
        updates[f"PATH_SEEN_BUCKET_{bucket}"].append(path)
