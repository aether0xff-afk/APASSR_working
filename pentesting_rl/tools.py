"""Tool adapters for running different reconnaissance commands."""
from __future__ import annotations

from dataclasses import dataclass
import base64
import json
import shlex
from typing import Callable, Dict, List, Tuple

from pentesting_rl.knowledge import KnowledgeStorage
from pentesting_rl.parser import HTTPHeaderParser, NmapXMLParser, ParsedResult, WebJSONParser
from pentesting_rl.policy import PolicyOption


Resolver = Callable[[str, str], str]


@dataclass
class ToolCommand:
    command: str
    params: Dict[str, str]


class ToolAdapter:
    name = "base"

    def __init__(self, storage: KnowledgeStorage) -> None:
        self.storage = storage

    def build_command(
        self,
        options: Tuple[PolicyOption, PolicyOption, PolicyOption],
        target_ip: str,
        resolve_param: Resolver,
    ) -> ToolCommand:
        raise NotImplementedError

    def parse_output(self, output: str) -> ParsedResult:
        raise NotImplementedError

    def update_knowledge_from_command(
        self, command: str, params: Dict[str, str]
    ) -> tuple[set[str], Dict[str, List[str]]]:
        return set(), {}


def _collect_params(
    options: Tuple[PolicyOption, PolicyOption, PolicyOption],
    resolve_param: Resolver,
) -> Dict[str, str]:
    params: Dict[str, str] = {}
    for option in options:
        if not option.parameters:
            continue
        for key, value in option.parameters.items():
            resolved = resolve_param(key, value)
            if resolved != "":
                params[key] = resolved
    return params


def _build_pytool_command(tool_name: str, payload: Dict[str, object]) -> str:
    data = json.dumps(payload, separators=(",", ":"), ensure_ascii=True)
    encoded = base64.urlsafe_b64encode(data.encode("utf-8")).decode("ascii")
    return f"pytool {tool_name} {encoded}"


def _coerce_bool(value: str | None, default: bool = True) -> bool:
    if value is None:
        return default
    lowered = value.strip().lower()
    if lowered in {"1", "true", "yes", "on"}:
        return True
    if lowered in {"0", "false", "no", "off"}:
        return False
    return default


def _coerce_int(value: str | None, default: int) -> int:
    if value is None:
        return default
    try:
        return int(value)
    except ValueError:
        return default


def _cookie_header_from_storage(storage: KnowledgeStorage) -> str:
    cookies = storage.store.get("HTTP_SET_COOKIE", [])
    jar: Dict[str, str] = {}
    for cookie in cookies:
        value = str(cookie).split(";", 1)[0]
        if "=" not in value:
            continue
        name, cookie_value = value.split("=", 1)
        name = name.strip()
        cookie_value = cookie_value.strip()
        if name:
            jar[name] = cookie_value
    if not jar:
        return ""
    return "; ".join(f"{name}={val}" for name, val in jar.items())


class NmapTool(ToolAdapter):
    name = "nmap"

    def __init__(self, storage: KnowledgeStorage) -> None:
        super().__init__(storage)
        self.parser = NmapXMLParser(storage)

    def build_command(
        self,
        options: Tuple[PolicyOption, PolicyOption, PolicyOption],
        target_ip: str,
        resolve_param: Resolver,
    ) -> ToolCommand:
        parts: List[str] = ["nmap"]
        params: Dict[str, str] = {}
        for option in options:
            if option.parameters:
                for kk, value in option.parameters.items():
                    resolved = resolve_param(kk, value)
                    if resolved:
                        params[kk] = resolved
                        parts.append(resolved)
        parts.append(target_ip)
        parts.extend(["-oX", "-"])
        command = " ".join(parts)
        return ToolCommand(command, params)

    def parse_output(self, output: str) -> ParsedResult:
        return self.parser.parse_and_update(output)

    def update_knowledge_from_command(
        self, command: str, params: Dict[str, str]
    ) -> tuple[set[str], Dict[str, List[str]]]:
        script_sets = _extract_script_sets(command)
        if not script_sets:
            return set(), {}
        mapping = {"Script_Set": script_sets, "SCRIPT_SET": script_sets}
        return self.storage.update_many_with_values(mapping)


class HttpHeadersTool(ToolAdapter):
    name = "http-headers"

    def __init__(self, storage: KnowledgeStorage) -> None:
        super().__init__(storage)
        self.parser = HTTPHeaderParser(storage)

    def build_command(
        self,
        options: Tuple[PolicyOption, PolicyOption, PolicyOption],
        target_ip: str,
        resolve_param: Resolver,
    ) -> ToolCommand:
        curl_tokens: List[str] = ["curl", "-sS"]
        path_override: str | None = None
        for option in options:
            if not option.parameters:
                continue
            for key, value in option.parameters.items():
                resolved = resolve_param(key, value)
                if key.upper() in {"PATH", "PATH_HINT"}:
                    path_override = resolved
                else:
                    curl_tokens.extend(shlex.split(resolved))

        if not _has_head_flag(curl_tokens):
            curl_tokens.append("-I")

        port_list = resolve_param("PORT_LIST", "{PORT_LIST}")
        port = _first_port(port_list) or "80"
        path_hint = path_override or resolve_param("PATH_HINT", "{PATH_HINT}")
        path = _normalize_path(path_hint)
        url = f"http://{target_ip}:{port}{path}"
        curl_tokens.append(url)
        command = shlex.join(curl_tokens)
        params = {
            "PORT_LIST": port_list,
            "PATH_HINT": path,
            "TARGET_IP": target_ip,
            "Target_IP": target_ip,
        }
        return ToolCommand(command, params)

    def parse_output(self, output: str) -> ParsedResult:
        return self.parser.parse_and_update(output)

    def update_knowledge_from_command(
        self, command: str, params: Dict[str, str]
    ) -> tuple[set[str], Dict[str, List[str]]]:
        mapping: Dict[str, List[str]] = {}
        target_ip = params.get("TARGET_IP")
        if target_ip:
            mapping.setdefault("TARGET_IP", []).append(target_ip)
            mapping.setdefault("Target_IP", []).append(target_ip)
        port_list = params.get("PORT_LIST")
        if port_list:
            mapping.setdefault("PORT_LIST", []).append(port_list)
            mapping.setdefault("Port_Spec", []).append(port_list)
        path_hint = params.get("PATH_HINT")
        if path_hint:
            mapping.setdefault("PATH_HINT", []).append(path_hint)
        if not mapping:
            return set(), {}
        return self.storage.update_many_with_values(mapping)


class HttpFetchTool(ToolAdapter):
    name = "http-fetch"

    def __init__(self, storage: KnowledgeStorage) -> None:
        super().__init__(storage)
        self.parser = WebJSONParser(storage)

    def build_command(
        self,
        options: Tuple[PolicyOption, PolicyOption, PolicyOption],
        target_ip: str,
        resolve_param: Resolver,
    ) -> ToolCommand:
        params = _collect_params(options, resolve_param)
        method = params.get("METHOD", "GET").upper()
        path_hint = params.get("PATH") or params.get("PATH_HINT") or resolve_param(
            "PATH_HINT", "{PATH_HINT}"
        )
        path = _normalize_path(path_hint)
        port_list = params.get("PORT_LIST") or resolve_param("PORT_LIST", "{PORT_LIST}")
        port = params.get("PORT") or _first_port(port_list) or "80"
        timeout = _coerce_int(params.get("TIMEOUT"), 5)
        follow = _coerce_bool(params.get("FOLLOW"), True)
        max_redirects = _coerce_int(params.get("MAX_REDIRECTS"), 3)
        scheme = params.get("SCHEME") or ("https" if str(port) == "443" else "http")
        headers: Dict[str, str] = {}
        if "USER_AGENT" in params:
            headers["User-Agent"] = params["USER_AGENT"]
        if "HEADER" in params and ":" in params["HEADER"]:
            key, value = params["HEADER"].split(":", 1)
            headers[key.strip()] = value.strip()

        payload = {
            "target_ip": target_ip,
            "port": port,
            "path": path,
            "method": method,
            "timeout": timeout,
            "follow_redirects": follow,
            "max_redirects": max_redirects,
            "headers": headers,
            "scheme": scheme,
        }
        command = _build_pytool_command(self.name, payload)
        params_out = {
            "TARGET_IP": target_ip,
            "Target_IP": target_ip,
            "PORT_LIST": port_list,
            "Port_Spec": port_list,
            "PATH_HINT": path,
            "METHOD": method,
        }
        return ToolCommand(command, params_out)

    def parse_output(self, output: str) -> ParsedResult:
        return self.parser.parse_and_update(output)

    def update_knowledge_from_command(
        self, command: str, params: Dict[str, str]
    ) -> tuple[set[str], Dict[str, List[str]]]:
        mapping: Dict[str, List[str]] = {}
        for key in ("TARGET_IP", "Target_IP", "PORT_LIST", "Port_Spec", "PATH_HINT", "METHOD"):
            value = params.get(key)
            if value:
                mapping.setdefault(key, []).append(value)
        if not mapping:
            return set(), {}
        return self.storage.update_many_with_values(mapping)


class RobotsSitemapTool(ToolAdapter):
    name = "robots-sitemap"

    def __init__(self, storage: KnowledgeStorage) -> None:
        super().__init__(storage)
        self.parser = WebJSONParser(storage)

    def build_command(
        self,
        options: Tuple[PolicyOption, PolicyOption, PolicyOption],
        target_ip: str,
        resolve_param: Resolver,
    ) -> ToolCommand:
        params = _collect_params(options, resolve_param)
        base_path = params.get("BASE_PATH") or params.get("PATH") or resolve_param(
            "PATH_HINT", "{PATH_HINT}"
        )
        base_path = _normalize_path(base_path)
        port_list = params.get("PORT_LIST") or resolve_param("PORT_LIST", "{PORT_LIST}")
        port = params.get("PORT") or _first_port(port_list) or "80"
        timeout = _coerce_int(params.get("TIMEOUT"), 5)
        mode = params.get("MODE", "ROBOTS_SITEMAP")
        scheme = params.get("SCHEME") or ("https" if str(port) == "443" else "http")

        payload = {
            "target_ip": target_ip,
            "port": port,
            "base_path": base_path,
            "timeout": timeout,
            "mode": mode,
            "scheme": scheme,
        }
        command = _build_pytool_command(self.name, payload)
        params_out = {
            "TARGET_IP": target_ip,
            "Target_IP": target_ip,
            "PORT_LIST": port_list,
            "Port_Spec": port_list,
            "PATH_HINT": base_path,
            "MODE": mode,
        }
        return ToolCommand(command, params_out)

    def parse_output(self, output: str) -> ParsedResult:
        return self.parser.parse_and_update(output)

    def update_knowledge_from_command(
        self, command: str, params: Dict[str, str]
    ) -> tuple[set[str], Dict[str, List[str]]]:
        mapping: Dict[str, List[str]] = {}
        for key in ("TARGET_IP", "Target_IP", "PORT_LIST", "Port_Spec", "PATH_HINT", "MODE"):
            value = params.get(key)
            if value:
                mapping.setdefault(key, []).append(value)
        if not mapping:
            return set(), {}
        return self.storage.update_many_with_values(mapping)


class HtmlCrawlerTool(ToolAdapter):
    name = "html-crawler"

    def __init__(self, storage: KnowledgeStorage) -> None:
        super().__init__(storage)
        self.parser = WebJSONParser(storage)

    def build_command(
        self,
        options: Tuple[PolicyOption, PolicyOption, PolicyOption],
        target_ip: str,
        resolve_param: Resolver,
    ) -> ToolCommand:
        params = _collect_params(options, resolve_param)
        path_hint = params.get("PATH") or params.get("PATH_HINT") or resolve_param(
            "PATH_HINT", "{PATH_HINT}"
        )
        path = _normalize_path(path_hint)
        port_list = params.get("PORT_LIST") or resolve_param("PORT_LIST", "{PORT_LIST}")
        port = params.get("PORT") or _first_port(port_list) or "80"
        timeout = _coerce_int(params.get("TIMEOUT"), 5)
        max_pages = _coerce_int(params.get("MAX_PAGES"), 3)
        max_depth = _coerce_int(params.get("MAX_DEPTH"), 1)
        fetch_scripts = _coerce_bool(params.get("FETCH_SCRIPTS"), False)
        max_scripts = _coerce_int(params.get("MAX_SCRIPTS"), 3)
        scheme = params.get("SCHEME") or ("https" if str(port) == "443" else "http")

        payload = {
            "target_ip": target_ip,
            "port": port,
            "path": path,
            "timeout": timeout,
            "max_pages": max_pages,
            "max_depth": max_depth,
            "fetch_scripts": fetch_scripts,
            "max_scripts": max_scripts,
            "scheme": scheme,
        }
        command = _build_pytool_command(self.name, payload)
        params_out = {
            "TARGET_IP": target_ip,
            "Target_IP": target_ip,
            "PORT_LIST": port_list,
            "Port_Spec": port_list,
            "PATH_HINT": path,
        }
        return ToolCommand(command, params_out)

    def parse_output(self, output: str) -> ParsedResult:
        return self.parser.parse_and_update(output)

    def update_knowledge_from_command(
        self, command: str, params: Dict[str, str]
    ) -> tuple[set[str], Dict[str, List[str]]]:
        mapping: Dict[str, List[str]] = {}
        for key in ("TARGET_IP", "Target_IP", "PORT_LIST", "Port_Spec", "PATH_HINT"):
            value = params.get(key)
            if value:
                mapping.setdefault(key, []).append(value)
        if not mapping:
            return set(), {}
        return self.storage.update_many_with_values(mapping)


class DirEnumTool(ToolAdapter):
    name = "dir-enum"

    def __init__(self, storage: KnowledgeStorage) -> None:
        super().__init__(storage)
        self.parser = WebJSONParser(storage)

    def build_command(
        self,
        options: Tuple[PolicyOption, PolicyOption, PolicyOption],
        target_ip: str,
        resolve_param: Resolver,
    ) -> ToolCommand:
        params = _collect_params(options, resolve_param)
        base_path = params.get("BASE_PATH") or params.get("PATH") or resolve_param(
            "PATH_HINT", "{PATH_HINT}"
        )
        base_path = _normalize_path(base_path)
        port_list = params.get("PORT_LIST") or resolve_param("PORT_LIST", "{PORT_LIST}")
        port = params.get("PORT") or _first_port(port_list) or "80"
        timeout = _coerce_int(params.get("TIMEOUT"), 4)
        method = params.get("METHOD", "HEAD")
        wordlist = params.get("WORDLIST", "small")
        max_paths = _coerce_int(params.get("MAX_PATHS"), 0)
        scheme = params.get("SCHEME") or ("https" if str(port) == "443" else "http")

        payload = {
            "target_ip": target_ip,
            "port": port,
            "base_path": base_path,
            "timeout": timeout,
            "method": method,
            "wordlist": wordlist,
            "max_paths": max_paths,
            "scheme": scheme,
        }
        command = _build_pytool_command(self.name, payload)
        params_out = {
            "TARGET_IP": target_ip,
            "Target_IP": target_ip,
            "PORT_LIST": port_list,
            "Port_Spec": port_list,
            "PATH_HINT": base_path,
            "WORDLIST": wordlist,
        }
        return ToolCommand(command, params_out)

    def parse_output(self, output: str) -> ParsedResult:
        return self.parser.parse_and_update(output)

    def update_knowledge_from_command(
        self, command: str, params: Dict[str, str]
    ) -> tuple[set[str], Dict[str, List[str]]]:
        mapping: Dict[str, List[str]] = {}
        for key in ("TARGET_IP", "Target_IP", "PORT_LIST", "Port_Spec", "PATH_HINT", "WORDLIST"):
            value = params.get(key)
            if value:
                mapping.setdefault(key, []).append(value)
        if not mapping:
            return set(), {}
        return self.storage.update_many_with_values(mapping)


class HintScannerTool(ToolAdapter):
    name = "hint-scanner"

    def __init__(self, storage: KnowledgeStorage) -> None:
        super().__init__(storage)
        self.parser = WebJSONParser(storage)

    def build_command(
        self,
        options: Tuple[PolicyOption, PolicyOption, PolicyOption],
        target_ip: str,
        resolve_param: Resolver,
    ) -> ToolCommand:
        params = _collect_params(options, resolve_param)
        path_hint = params.get("PATH") or params.get("PATH_HINT") or resolve_param(
            "PATH_HINT", "{PATH_HINT}"
        )
        path = _normalize_path(path_hint)
        port_list = params.get("PORT_LIST") or resolve_param("PORT_LIST", "{PORT_LIST}")
        port = params.get("PORT") or _first_port(port_list) or "80"
        timeout = _coerce_int(params.get("TIMEOUT"), 5)
        max_bytes = _coerce_int(params.get("MAX_BYTES"), 200_000)
        scheme = params.get("SCHEME") or ("https" if str(port) == "443" else "http")

        payload = {
            "target_ip": target_ip,
            "port": port,
            "path": path,
            "timeout": timeout,
            "max_bytes": max_bytes,
            "scheme": scheme,
        }
        command = _build_pytool_command(self.name, payload)
        params_out = {
            "TARGET_IP": target_ip,
            "Target_IP": target_ip,
            "PORT_LIST": port_list,
            "Port_Spec": port_list,
            "PATH_HINT": path,
        }
        return ToolCommand(command, params_out)

    def parse_output(self, output: str) -> ParsedResult:
        return self.parser.parse_and_update(output)

    def update_knowledge_from_command(
        self, command: str, params: Dict[str, str]
    ) -> tuple[set[str], Dict[str, List[str]]]:
        mapping: Dict[str, List[str]] = {}
        for key in ("TARGET_IP", "Target_IP", "PORT_LIST", "Port_Spec", "PATH_HINT"):
            value = params.get(key)
            if value:
                mapping.setdefault(key, []).append(value)
        if not mapping:
            return set(), {}
        return self.storage.update_many_with_values(mapping)


class StatefulHttpTool(ToolAdapter):
    name = "stateful-http"

    def __init__(self, storage: KnowledgeStorage) -> None:
        super().__init__(storage)
        self.parser = WebJSONParser(storage)

    def build_command(
        self,
        options: Tuple[PolicyOption, PolicyOption, PolicyOption],
        target_ip: str,
        resolve_param: Resolver,
    ) -> ToolCommand:
        params = _collect_params(options, resolve_param)
        method = params.get("METHOD", "GET").upper()
        path_hint = params.get("PATH") or params.get("PATH_HINT") or resolve_param(
            "PATH_HINT", "{PATH_HINT}"
        )
        path = _normalize_path(path_hint)
        port_list = params.get("PORT_LIST") or resolve_param("PORT_LIST", "{PORT_LIST}")
        port = params.get("PORT") or _first_port(port_list) or "80"
        timeout = _coerce_int(params.get("TIMEOUT"), 5)
        follow = _coerce_bool(params.get("FOLLOW"), True)
        max_redirects = _coerce_int(params.get("MAX_REDIRECTS"), 3)
        scheme = params.get("SCHEME") or ("https" if str(port) == "443" else "http")
        cookie_header = params.get("COOKIE_HEADER") or _cookie_header_from_storage(self.storage)
        headers: Dict[str, str] = {}
        if cookie_header:
            headers["Cookie"] = cookie_header

        payload = {
            "target_ip": target_ip,
            "port": port,
            "path": path,
            "method": method,
            "timeout": timeout,
            "follow_redirects": follow,
            "max_redirects": max_redirects,
            "headers": headers,
            "cookie_header": cookie_header,
            "scheme": scheme,
        }
        command = _build_pytool_command(self.name, payload)
        params_out = {
            "TARGET_IP": target_ip,
            "Target_IP": target_ip,
            "PORT_LIST": port_list,
            "Port_Spec": port_list,
            "PATH_HINT": path,
            "METHOD": method,
        }
        return ToolCommand(command, params_out)

    def parse_output(self, output: str) -> ParsedResult:
        return self.parser.parse_and_update(output)

    def update_knowledge_from_command(
        self, command: str, params: Dict[str, str]
    ) -> tuple[set[str], Dict[str, List[str]]]:
        mapping: Dict[str, List[str]] = {}
        for key in ("TARGET_IP", "Target_IP", "PORT_LIST", "Port_Spec", "PATH_HINT", "METHOD"):
            value = params.get(key)
            if value:
                mapping.setdefault(key, []).append(value)
        if not mapping:
            return set(), {}
        return self.storage.update_many_with_values(mapping)


class ParamInfluenceTool(ToolAdapter):
    name = "param-influence"

    def __init__(self, storage: KnowledgeStorage) -> None:
        super().__init__(storage)
        self.parser = WebJSONParser(storage)

    def build_command(
        self,
        options: Tuple[PolicyOption, PolicyOption, PolicyOption],
        target_ip: str,
        resolve_param: Resolver,
    ) -> ToolCommand:
        params = _collect_params(options, resolve_param)
        path_hint = params.get("PATH") or params.get("PATH_HINT") or resolve_param(
            "PATH_HINT", "{PATH_HINT}"
        )
        path = _normalize_path(path_hint)
        port_list = params.get("PORT_LIST") or resolve_param("PORT_LIST", "{PORT_LIST}")
        port = params.get("PORT") or _first_port(port_list) or "80"
        timeout = _coerce_int(params.get("TIMEOUT"), 5)
        max_params = _coerce_int(params.get("MAX_PARAMS"), 5)
        scheme = params.get("SCHEME") or ("https" if str(port) == "443" else "http")

        param_list = list(dict.fromkeys(self.storage.store.get("PARAM_DETECTED", [])))
        if not param_list:
            param_list = ["id", "file", "user", "name"]

        payload = {
            "target_ip": target_ip,
            "port": port,
            "path": path,
            "timeout": timeout,
            "params": param_list,
            "max_params": max_params,
            "scheme": scheme,
        }
        command = _build_pytool_command(self.name, payload)
        params_out = {
            "TARGET_IP": target_ip,
            "Target_IP": target_ip,
            "PORT_LIST": port_list,
            "Port_Spec": port_list,
            "PATH_HINT": path,
        }
        return ToolCommand(command, params_out)

    def parse_output(self, output: str) -> ParsedResult:
        return self.parser.parse_and_update(output)

    def update_knowledge_from_command(
        self, command: str, params: Dict[str, str]
    ) -> tuple[set[str], Dict[str, List[str]]]:
        mapping: Dict[str, List[str]] = {}
        for key in ("TARGET_IP", "Target_IP", "PORT_LIST", "Port_Spec", "PATH_HINT"):
            value = params.get(key)
            if value:
                mapping.setdefault(key, []).append(value)
        if not mapping:
            return set(), {}
        return self.storage.update_many_with_values(mapping)


class ToolRegistry:
    def __init__(self, storage: KnowledgeStorage) -> None:
        tools = (
            NmapTool(storage),
            HttpHeadersTool(storage),
            HttpFetchTool(storage),
            RobotsSitemapTool(storage),
            HtmlCrawlerTool(storage),
            DirEnumTool(storage),
            HintScannerTool(storage),
            StatefulHttpTool(storage),
            ParamInfluenceTool(storage),
        )
        self._tools = {tool.name: tool for tool in tools}

    def get(self, name: str) -> ToolAdapter:
        if name not in self._tools:
            available = ", ".join(sorted(self._tools))
            raise ValueError(f"Unknown tool '{name}'. Available: {available}")
        return self._tools[name]

    def available(self) -> List[str]:
        return sorted(self._tools.keys())


def _extract_script_sets(command: str) -> List[str]:
    script_sets: List[str] = []
    tokens = shlex.split(command)
    idx = 0
    while idx < len(tokens):
        token = tokens[idx]
        if token == "--script" and idx + 1 < len(tokens):
            script_sets.append(tokens[idx + 1])
            idx += 2
            continue
        if token.startswith("--script="):
            script_sets.append(token.split("=", 1)[1])
        idx += 1
    return script_sets


def _first_port(port_list: str) -> str | None:
    if not port_list:
        return None
    first = port_list.split(",")[0].strip()
    return first or None


def _normalize_path(path_hint: str) -> str:
    if not path_hint:
        return "/"
    if path_hint.startswith("http://") or path_hint.startswith("https://"):
        parts = path_hint.split("/", 3)
        if len(parts) >= 4:
            return "/" + parts[3]
        return "/"
    if path_hint.startswith("/"):
        return path_hint
    return f"/{path_hint}"


def _has_head_flag(tokens: List[str]) -> bool:
    for idx, token in enumerate(tokens):
        if token in {"-I", "--head"}:
            return True
        if token == "-X" and idx + 1 < len(tokens) and tokens[idx + 1].upper() == "HEAD":
            return True
    return False
