"""Tool adapters for running different reconnaissance commands."""
from __future__ import annotations

from dataclasses import dataclass
import shlex
from typing import Callable, Dict, List, Tuple

from pentesting_rl.knowledge import KnowledgeStorage
from pentesting_rl.parser import HTTPHeaderParser, NmapXMLParser, ParsedResult
from pentesting_rl.policy import PolicyOption


Resolver = Callable[[str, str], str]


@dataclass
class ToolCommand:
    command: str
    params: Dict[str, str]


class ToolAdapter:
    name = "base"

    def __init__(self, storage: KnowledgeStorage) -> None:
        self.storage = storage

    def build_command(
        self,
        options: Tuple[PolicyOption, PolicyOption, PolicyOption],
        target_ip: str,
        resolve_param: Resolver,
    ) -> ToolCommand:
        raise NotImplementedError

    def parse_output(self, output: str) -> ParsedResult:
        raise NotImplementedError

    def update_knowledge_from_command(
        self, command: str, params: Dict[str, str]
    ) -> tuple[set[str], Dict[str, List[str]]]:
        return set(), {}


class NmapTool(ToolAdapter):
    name = "nmap"

    def __init__(self, storage: KnowledgeStorage) -> None:
        super().__init__(storage)
        self.parser = NmapXMLParser(storage)

    def build_command(
        self,
        options: Tuple[PolicyOption, PolicyOption, PolicyOption],
        target_ip: str,
        resolve_param: Resolver,
    ) -> ToolCommand:
        parts: List[str] = ["nmap"]
        params: Dict[str, str] = {}
        for option in options:
            if option.parameters:
                for kk, value in option.parameters.items():
                    resolved = resolve_param(kk, value)
                    if resolved:
                        params[kk] = resolved
                        parts.append(resolved)
        parts.append(target_ip)
        parts.extend(["-oX", "-"])
        command = " ".join(parts)
        return ToolCommand(command, params)

    def parse_output(self, output: str) -> ParsedResult:
        return self.parser.parse_and_update(output)

    def update_knowledge_from_command(
        self, command: str, params: Dict[str, str]
    ) -> tuple[set[str], Dict[str, List[str]]]:
        script_sets = _extract_script_sets(command)
        if not script_sets:
            return set(), {}
        mapping = {"Script_Set": script_sets, "SCRIPT_SET": script_sets}
        return self.storage.update_many_with_values(mapping)


class HttpHeadersTool(ToolAdapter):
    name = "http-headers"

    def __init__(self, storage: KnowledgeStorage) -> None:
        super().__init__(storage)
        self.parser = HTTPHeaderParser(storage)

    def build_command(
        self,
        options: Tuple[PolicyOption, PolicyOption, PolicyOption],
        target_ip: str,
        resolve_param: Resolver,
    ) -> ToolCommand:
        curl_tokens: List[str] = ["curl", "-sS"]
        path_override: str | None = None
        for option in options:
            if not option.parameters:
                continue
            for key, value in option.parameters.items():
                resolved = resolve_param(key, value)
                if key.upper() in {"PATH", "PATH_HINT"}:
                    path_override = resolved
                else:
                    curl_tokens.extend(shlex.split(resolved))

        if not _has_head_flag(curl_tokens):
            curl_tokens.append("-I")

        port_list = resolve_param("PORT_LIST", "{PORT_LIST}")
        port = _first_port(port_list) or "80"
        path_hint = path_override or resolve_param("PATH_HINT", "{PATH_HINT}")
        path = _normalize_path(path_hint)
        url = f"http://{target_ip}:{port}{path}"
        curl_tokens.append(url)
        command = shlex.join(curl_tokens)
        params = {
            "PORT_LIST": port_list,
            "PATH_HINT": path,
            "TARGET_IP": target_ip,
            "Target_IP": target_ip,
        }
        return ToolCommand(command, params)

    def parse_output(self, output: str) -> ParsedResult:
        return self.parser.parse_and_update(output)

    def update_knowledge_from_command(
        self, command: str, params: Dict[str, str]
    ) -> tuple[set[str], Dict[str, List[str]]]:
        mapping: Dict[str, List[str]] = {}
        target_ip = params.get("TARGET_IP")
        if target_ip:
            mapping.setdefault("TARGET_IP", []).append(target_ip)
            mapping.setdefault("Target_IP", []).append(target_ip)
        port_list = params.get("PORT_LIST")
        if port_list:
            mapping.setdefault("PORT_LIST", []).append(port_list)
            mapping.setdefault("Port_Spec", []).append(port_list)
        path_hint = params.get("PATH_HINT")
        if path_hint:
            mapping.setdefault("PATH_HINT", []).append(path_hint)
        if not mapping:
            return set(), {}
        return self.storage.update_many_with_values(mapping)


class ToolRegistry:
    def __init__(self, storage: KnowledgeStorage) -> None:
        tools = (NmapTool(storage), HttpHeadersTool(storage))
        self._tools = {tool.name: tool for tool in tools}

    def get(self, name: str) -> ToolAdapter:
        if name not in self._tools:
            available = ", ".join(sorted(self._tools))
            raise ValueError(f"Unknown tool '{name}'. Available: {available}")
        return self._tools[name]

    def available(self) -> List[str]:
        return sorted(self._tools.keys())


def _extract_script_sets(command: str) -> List[str]:
    script_sets: List[str] = []
    tokens = shlex.split(command)
    idx = 0
    while idx < len(tokens):
        token = tokens[idx]
        if token == "--script" and idx + 1 < len(tokens):
            script_sets.append(tokens[idx + 1])
            idx += 2
            continue
        if token.startswith("--script="):
            script_sets.append(token.split("=", 1)[1])
        idx += 1
    return script_sets


def _first_port(port_list: str) -> str | None:
    if not port_list:
        return None
    first = port_list.split(",")[0].strip()
    return first or None


def _normalize_path(path_hint: str) -> str:
    if not path_hint:
        return "/"
    if path_hint.startswith("http://") or path_hint.startswith("https://"):
        parts = path_hint.split("/", 3)
        if len(parts) >= 4:
            return "/" + parts[3]
        return "/"
    if path_hint.startswith("/"):
        return path_hint
    return f"/{path_hint}"


def _has_head_flag(tokens: List[str]) -> bool:
    for idx, token in enumerate(tokens):
        if token in {"-I", "--head"}:
            return True
        if token == "-X" and idx + 1 < len(tokens) and tokens[idx + 1].upper() == "HEAD":
            return True
    return False
